# Milestone v1.2: Performance Optimization

**Status:** SHIPPED 2026-02-02
**Phases:** 8-10
**Total Plans:** 6

## Overview

Performance optimization milestone adding profiling instrumentation, latency optimizations, and
memory management. Profiling builds expose timing/cache/atlas metrics with zero release overhead.
Multi-page atlas eliminates mid-frame resets. LRU eviction bounds cache memory growth.

## Phases

### Phase 8: Instrumentation

**Goal:** Profiling builds expose performance characteristics with zero release overhead
**Depends on:** None
**Plans:** 2 plans

Plans:
- [x] 08-01-PLAN.md — ProfileMetrics struct + timing instrumentation (INST-01, INST-02)
- [x] 08-02-PLAN.md — Cache/atlas tracking + API exposure (INST-03, INST-04, INST-05)

**Requirements:**
- INST-01: Profiling builds with `-d profile` flag have zero release overhead
- INST-02: Frame time breakdown shows layout/rasterize/upload/draw phases
- INST-03: Cache hit/miss rates tracked for glyph, metrics, and layout caches
- INST-04: Memory allocation tracking shows peak usage and growth rate
- INST-05: Atlas utilization metrics show used/total pixels per page

**Success Criteria:**
1. Developer builds with `-d profile` and sees frame time breakdown in milliseconds
2. Cache hit rates show percentages for each cache type (glyph, metrics, layout)
3. Memory tracking shows peak atlas usage and growth rate per frame
4. Atlas metrics show utilization percentage per page
5. Release builds have zero profiling overhead (conditional compilation verified)

### Phase 9: Latency Optimizations

**Goal:** Hot paths execute with minimal stalls and redundant computation
**Depends on:** Phase 8 (instrumentation validates improvements)
**Plans:** 3 plans

Plans:
- [x] 09-01-PLAN.md — Multi-page atlas (LATENCY-01)
- [x] 09-02-PLAN.md — Metrics cache + collision detection (LATENCY-02, LATENCY-03)
- [x] 09-03-PLAN.md — GPU emoji scaling + integration (LATENCY-04)

**Requirements:**
- LATENCY-01: Multi-page atlas eliminates mid-frame reset stalls
- LATENCY-02: FreeType metrics cached by (font, size) tuple
- LATENCY-03: Glyph cache validates hash collisions with secondary key
- LATENCY-04: Color emoji scaling uses GPU or cached scaled bitmaps

**Success Criteria:**
1. Rendering large text never triggers mid-frame atlas reset (multi-page support)
2. Metrics cache reduces FreeType FFI calls (cache hit rate >80% in typical usage)
3. Glyph cache handles hash collisions without corrupting atlas (secondary key validation)
4. Color emoji rendering uses GPU scaling or cached bitmaps (no per-frame CPU bicubic)

### Phase 10: Memory Optimization

**Goal:** Cache memory usage bounded and predictable
**Depends on:** Phase 8 (instrumentation shows memory growth)
**Plans:** 1 plan

Plans:
- [x] 10-01-PLAN.md — Bounded glyph cache with LRU eviction (MEM-01)

**Requirements:**
- MEM-01: Glyph cache uses LRU eviction with configurable max entries

**Success Criteria:**
1. Glyph cache respects max entry limit (configurable, default reasonable)
2. LRU eviction removes least-recently-used glyphs when limit reached
3. Memory tracking shows cache stabilizes after warmup (no unbounded growth)

---

## Milestone Summary

**Key Decisions:**
- Timing fields unconditional in structs; only accessed in profile builds (V limitation)
- Separate textures per atlas page (not texture arrays) for Sokol/gg compatibility
- O(n) scan for LRU eviction (simple, sufficient for 4096 entries)
- Cache key = face pointer XOR (size_units << 32) for metrics cache
- use_original_color as BGRA/emoji indicator for GPU scaling

**Issues Resolved:**
- V doesn't allow $if inside struct definitions — timing fields always exist
- Multi-page atlas integration required renderer.v/api.v fixes for new structure

**Issues Deferred:**
- Metrics cache stats not exposed in ProfileMetrics (internal tracking exists)

**Technical Debt Incurred:**
- None significant — clean implementation

---

*For current project status, see .planning/PROJECT.md*
