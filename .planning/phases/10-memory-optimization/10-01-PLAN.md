---
phase: 10-memory-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - renderer.v
  - context.v
  - api.v
autonomous: true

must_haves:
  truths:
    - "Glyph cache respects max entry limit (4096 default)"
    - "LRU eviction removes least-recently-used glyphs when limit reached"
    - "Config allows init-time max_cache_entries override"
    - "Minimum 256 enforced silently"
  artifacts:
    - path: "renderer.v"
      provides: "LRU eviction with frame counter tracking"
      contains: "cache_ages"
    - path: "renderer.v"
      provides: "Config struct with max_glyph_cache_entries"
      contains: "RendererConfig"
    - path: "context.v"
      provides: "Eviction count in ProfileMetrics"
      contains: "glyph_cache_evictions"
  key_links:
    - from: "renderer.v get_or_load_glyph"
      to: "cache_ages map"
      via: "age update on cache hit"
      pattern: "cache_ages\\[key\\].*frame_counter"
    - from: "renderer.v insert path"
      to: "evict_oldest_glyph"
      via: "capacity check before insert"
      pattern: "cache\\.len.*max_cache_entries"
---

<objective>
Add bounded glyph cache with LRU eviction to prevent unbounded memory growth.

Purpose: MEM-01 requires glyph cache to use LRU eviction with configurable max entries. Currently
the cache grows without limit, creating memory leak risk.

Output: Renderer with max_cache_entries (default 4096), cache_ages tracking, on-insert eviction,
and ProfileMetrics.glyph_cache_evictions instrumentation.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-memory-optimization/10-CONTEXT.md
@.planning/phases/10-memory-optimization/10-RESEARCH.md
@renderer.v
@context.v
@api.v
@glyph_atlas.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cache age tracking and config to Renderer</name>
  <files>renderer.v</files>
  <action>
Add fields to Renderer struct:

```v
pub struct Renderer {
mut:
    // ... existing fields ...
    cache_ages       map[u64]u64  // key -> last_used_frame
    max_cache_entries int = 4096  // capacity limit (enforced minimum 256)
    // Profile fields section - add:
    glyph_cache_evictions int
}
```

Add RendererConfig struct before new_renderer:

```v
pub struct RendererConfig {
pub:
    max_glyph_cache_entries int = 4096
}
```

Add new_renderer_with_config function:

```v
pub fn new_renderer_with_config(mut ctx gg.Context, scale_factor f32, cfg RendererConfig) &Renderer {
    mut atlas := new_glyph_atlas(mut ctx, 1024, 1024) or { panic(err) }
    safe_scale := if scale_factor > 0 { scale_factor } else { 1.0 }
    max := if cfg.max_glyph_cache_entries < 256 { 256 } else { cfg.max_glyph_cache_entries }
    return &Renderer{
        ctx:               ctx
        atlas:             atlas
        sampler:           create_linear_sampler()
        cache:             map[u64]CachedGlyph{}
        cache_ages:        map[u64]u64{}
        max_cache_entries: max
        scale_factor:      safe_scale
        scale_inv:         1.0 / safe_scale
    }
}
```

Update existing new_renderer to use default config internally (preserve API):

```v
pub fn new_renderer(mut ctx gg.Context, scale_factor f32) &Renderer {
    return new_renderer_with_config(mut ctx, scale_factor, RendererConfig{})
}
```

Update new_renderer_atlas_size similarly - add config parameter or use default.
  </action>
  <verify>v -check-syntax renderer.v</verify>
  <done>Renderer has cache_ages map, max_cache_entries field, RendererConfig struct, and
  new_renderer_with_config function</done>
</task>

<task type="auto">
  <name>Task 2: Implement LRU eviction in get_or_load_glyph</name>
  <files>renderer.v</files>
  <action>
Modify get_or_load_glyph to:

1. **Update age on cache hit** - After the `if key in renderer.cache` check succeeds, add:
```v
if key in renderer.cache {
    $if profile ? {
        renderer.glyph_cache_hits++
    }
    // Update LRU age
    renderer.cache_ages[key] = renderer.atlas.frame_counter
    cached := renderer.cache[key]
    // ... rest of existing code ...
}
```

2. **Check capacity before insert** - Before `renderer.cache[key] = cached_glyph`, add eviction:
```v
// Evict oldest if at capacity
if renderer.cache.len >= renderer.max_cache_entries && key !in renderer.cache {
    renderer.evict_oldest_glyph()
}

renderer.cache[key] = cached_glyph
renderer.cache_ages[key] = renderer.atlas.frame_counter
```

3. **Add evict_oldest_glyph helper** - Add new private function:
```v
fn (mut renderer Renderer) evict_oldest_glyph() {
    mut oldest_key := u64(0)
    mut oldest_age := u64(0xFFFFFFFFFFFFFFFF)
    for k, age in renderer.cache_ages {
        if age < oldest_age {
            oldest_age = age
            oldest_key = k
        }
    }
    if oldest_key != 0 || oldest_age != u64(0xFFFFFFFFFFFFFFFF) {
        renderer.cache.delete(oldest_key)
        renderer.cache_ages.delete(oldest_key)
        $if profile ? {
            renderer.glyph_cache_evictions++
        }
    }
}
```

Note: Atlas space is left as hole (per CONTEXT.md decision). Evicted glyph's bitmap remains in
atlas page until that page is evicted via existing LRU page eviction.
  </action>
  <verify>v -check-syntax renderer.v && v fmt -w renderer.v</verify>
  <done>Cache hit updates age, insert path checks capacity, evict_oldest_glyph removes LRU entry</done>
</task>

<task type="auto">
  <name>Task 3: Add eviction instrumentation to ProfileMetrics</name>
  <files>context.v, api.v</files>
  <action>
1. **Extend ProfileMetrics in context.v** - Add field inside the `$if profile ?` block:
```v
pub struct ProfileMetrics {
pub mut:
    // ... existing fields ...
    // Cache statistics (INST-03) - add after layout_cache_misses:
    glyph_cache_evictions int
}
```

2. **Update print_summary in context.v** - Add eviction count to output after glyph cache line:
```v
println('Glyph Cache: ${m.glyph_cache_hit_rate():.1}% (${m.glyph_cache_hits}/${glyph_total}), ${m.glyph_cache_evictions} evictions')
```

3. **Update get_profile_metrics in api.v** - Add eviction count to returned struct:
```v
return ProfileMetrics{
    // ... existing fields ...
    glyph_cache_evictions: ts.renderer.glyph_cache_evictions
}
```

4. **Update reset_profile_metrics in api.v** - Reset eviction counter:
```v
ts.renderer.glyph_cache_evictions = 0
```
  </action>
  <verify>v -check-syntax context.v && v -check-syntax api.v</verify>
  <done>ProfileMetrics includes glyph_cache_evictions, get_profile_metrics returns it, print_summary
  shows it</done>
</task>

</tasks>

<verification>
1. `v -check-syntax renderer.v context.v api.v` - all pass
2. `v fmt -w renderer.v context.v api.v` - format clean
3. `v .` - full compile succeeds
4. Build with `-d profile` succeeds
5. Release build (no flags) succeeds and has no eviction code overhead
</verification>

<success_criteria>
- [ ] Renderer has cache_ages map tracking last_used_frame per glyph
- [ ] Renderer has max_cache_entries field (default 4096, minimum 256 enforced)
- [ ] RendererConfig struct allows init-time configuration
- [ ] new_renderer_with_config accepts config, new_renderer uses default
- [ ] Cache hit updates cache_ages[key] to current frame_counter
- [ ] Cache insert evicts oldest when at capacity (before inserting new)
- [ ] evict_oldest_glyph finds LRU entry via O(n) scan of cache_ages
- [ ] ProfileMetrics.glyph_cache_evictions tracks eviction count
- [ ] get_profile_metrics includes eviction count
- [ ] print_summary shows eviction count
- [ ] Code compiles in release (no profile flag) and profile modes
</success_criteria>

<output>
After completion, create `.planning/phases/10-memory-optimization/10-01-SUMMARY.md`
</output>
