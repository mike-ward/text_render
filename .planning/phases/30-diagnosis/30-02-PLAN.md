---
phase: 30-diagnosis
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - .planning/phases/30-diagnosis/30-DIAGNOSIS.md
autonomous: false

must_haves:
  truths:
    - "Each regression symptom has documented root cause with evidence"
    - "Each symptom is mapped to specific v1.6 phase (26, 27, or 28)"
    - "Double-buffer data loss pattern is confirmed or ruled out"
  artifacts:
    - path: ".planning/phases/30-diagnosis/30-DIAGNOSIS.md"
      provides: "Root cause documentation for all three symptoms"
      contains: "DIAG-01"
  key_links:
    - from: "30-DIAGNOSIS.md"
      to: "glyph_atlas.v"
      via: "Root cause references specific code paths"
      pattern: "swap_staging_buffers|staging_front|staging_back"
---

<objective>
Analyze Plan 01 diagnostic output, perform static code analysis of the
async double-buffer path, and document root causes for all three v1.6
regression symptoms in 30-DIAGNOSIS.md.

Purpose: Phase 30 deliverable — root causes documented so Phase 31 can
fix them.

Output: 30-DIAGNOSIS.md mapping each symptom to cause, evidence, and
offending v1.6 phase.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-diagnosis/30-RESEARCH.md
@.planning/phases/30-diagnosis/30-01-SUMMARY.md
@glyph_atlas.v
@renderer.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze async path and document root causes</name>
  <files>.planning/phases/30-diagnosis/30-DIAGNOSIS.md</files>
  <action>
Read the Plan 01 SUMMARY for empirical results. Then perform static code
analysis of the async double-buffer path. Document findings in
30-DIAGNOSIS.md.

**Critical code analysis (regardless of empirical results):**

The async commit path in renderer.v (lines 128-134) does:
```
for mut page in renderer.atlas.pages {
    if page.dirty {
        page.swap_staging_buffers()
        page.image.update_pixel_data(page.staging_front.data)
        page.dirty = false
    }
}
```

The double-buffer data flow per frame:
- Frame N: CPU writes new glyphs to staging_back. At commit: swap
  (front=old_back with new data, back=old_front with stale data),
  upload front to GPU.
- Frame N+1: CPU writes NEW glyphs to staging_back (which is now
  old_front — does NOT contain Frame N's glyphs). At commit: swap,
  upload front. This front is old_back from Frame N+1, which has
  Frame N+1 glyphs but NOT Frame N glyphs (those were in the other
  buffer).

**This is the classic double-buffer accumulation bug:** Each buffer only
has every-other-frame's data. Glyphs rasterized in frame N appear in
the GPU texture for frame N's upload, then DISAPPEAR in frame N+1's
upload (because that upload comes from the alternate buffer), then
REAPPEAR in frame N+2.

This explains:
- **DIAG-01 Flickering:** Glyphs alternate visible/invisible each frame
- **DIAG-02 Rendering delays:** New glyphs take 2 frames to stabilize
  (need to be written to BOTH buffers)
- **DIAG-03 Blank regions:** When scrolling to new area, glyphs in the
  "wrong" buffer appear blank for one frame. With rapid scroll, many
  glyphs are in this state simultaneously, creating visible blank regions.

**The sync path does NOT have this bug** because it copies staging_back
directly to image.data each frame — no alternation, no data loss.

**Root cause phase:** Phase 27 (async texture updates). The swap without
accumulation is the bug. Phase 26 (shelf packing) and Phase 28 (profiling)
are not contributing factors.

**Fix direction (for Phase 31):**
After swap, copy staging_front to staging_back so the new "back" buffer
starts with all accumulated glyph data. One memcpy per dirty page per
frame. This preserves CPU/GPU overlap while fixing accumulation.

Create 30-DIAGNOSIS.md with this structure:
```markdown
# Phase 30: Diagnosis Report

## Summary
[1-2 sentences: all three symptoms trace to Phase 27 async double-buffer
data loss]

## DIAG-01: Scroll Flickering
- **Root Cause:** [double-buffer alternation]
- **Evidence:** [code path analysis + empirical kill switch result]
- **Trigger:** [any frame with new glyph rasterization]
- **Offending Phase:** Phase 27 (async texture updates)
- **Code Path:** renderer.v commit() async path → swap_staging_buffers()

## DIAG-02: Rendering Delays
- **Root Cause:** [2-frame stabilization delay]
- **Evidence:** [new glyphs must exist in both buffers]
- **Trigger:** [first render of uncached glyph]
- **Offending Phase:** Phase 27

## DIAG-03: Blank Scroll Regions
- **Root Cause:** [new-area glyphs only in one buffer]
- **Evidence:** [rapid scroll = many single-buffer glyphs = visible blanks]
- **Trigger:** [scroll to area requiring new glyph rasterization]
- **Offending Phase:** Phase 27

## Fix Recommendation
[memcpy staging_front to staging_back after swap in commit()]

## Empirical Evidence
[Plan 01 kill switch results summary]
```

Ensure markdown lines do not exceed 99 characters.
After writing, run `v check-md -w .planning/phases/30-diagnosis/30-DIAGNOSIS.md`.
  </action>
  <verify>
30-DIAGNOSIS.md exists with all three DIAG sections.
`v check-md -w .planning/phases/30-diagnosis/30-DIAGNOSIS.md` passes.
Each DIAG section identifies root cause, evidence, trigger, and offending
phase.
  </verify>
  <done>
All three regression symptoms documented with root cause, evidence, and
phase attribution. Fix direction documented for Phase 31.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Root cause diagnosis for all three v1.6 regression symptoms, documented
in 30-DIAGNOSIS.md. Key finding: all three symptoms trace to Phase 27
async double-buffer swap without accumulation — staging_back after swap
contains stale data from 2 frames ago, causing glyphs to alternate
visible/invisible.
  </what-built>
  <how-to-verify>
1. Read `.planning/phases/30-diagnosis/30-DIAGNOSIS.md`
2. Verify the double-buffer data loss analysis matches your observation
   of the symptoms
3. Optionally run: `v -d diag run examples/stress_demo.v` and
   `v -d diag -d diag_sync run examples/stress_demo.v` to compare
   async vs sync behavior visually
4. Confirm the fix direction (memcpy after swap) makes sense
  </how-to-verify>
  <resume-signal>
Type "approved" if diagnosis is correct, or describe issues with the
analysis
  </resume-signal>
</task>

</tasks>

<verification>
1. 30-DIAGNOSIS.md exists and covers DIAG-01, DIAG-02, DIAG-03
2. Each symptom mapped to Phase 27 with specific code path
3. Fix recommendation documented
4. Human approved diagnosis accuracy
</verification>

<success_criteria>
- Root cause for all three symptoms documented with evidence
- Each symptom mapped to specific v1.6 phase
- Fix direction clear enough for Phase 31 to implement
- Human verification confirms diagnosis matches observed behavior
</success_criteria>

<output>
After completion, create `.planning/phases/30-diagnosis/30-02-SUMMARY.md`
</output>
