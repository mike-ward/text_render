---
phase: 30-diagnosis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/stress_demo.v
  - glyph_atlas.v
  - renderer.v
autonomous: true

must_haves:
  truths:
    - "Async kill switch test shows whether symptoms vanish with sync path"
    - "Automated scroll loop reliably triggers regression symptoms"
    - "Diagnostic logging captures buffer state at swap/upload/reset"
  artifacts:
    - path: "examples/stress_demo.v"
      provides: "Automated scroll stress mode via -d diag flag"
    - path: "glyph_atlas.v"
      provides: "Diagnostic logging in swap_staging_buffers and reset_page"
    - path: "renderer.v"
      provides: "Diagnostic logging in commit() showing buffer state"
  key_links:
    - from: "stress_demo.v"
      to: "renderer.v commit()"
      via: "ts.commit() per frame"
      pattern: "app\\.ts\\.commit\\(\\)"
---

<objective>
Add diagnostic instrumentation to the async texture upload path and create
a reproducible automated stress test that triggers the v1.6 regression
symptoms (flickering, delays, blank regions).

Purpose: Empirical data needed before documenting root causes. The
async_uploads kill switch isolates Phase 27 changes; automated scroll
triggers LRU eviction to expose blank regions.

Output: Modified stress_demo with `-d diag` automated scroll, diagnostic
logging in glyph_atlas.v and renderer.v behind `-d diag` flag.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-diagnosis/30-RESEARCH.md
@glyph_atlas.v
@renderer.v
@examples/stress_demo.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add diagnostic instrumentation to async upload path</name>
  <files>glyph_atlas.v, renderer.v</files>
  <action>
Add compile-time diagnostic logging behind `$if diag ?` flag in three
critical locations:

1. **glyph_atlas.v `swap_staging_buffers()`** — Log pre/post swap state:
   sample first 16 bytes of staging_front and staging_back before and
   after swap. Also log whether buffers are identical (suggests data loss
   from double-buffer ping-pong).

2. **glyph_atlas.v `reset_page()`** — Log when page reset occurs: page
   index, frame counter, number of cache entries about to be invalidated.

3. **renderer.v `commit()`** — In the async path (line ~128), log: page
   index, whether dirty, frame counter. In the sync path, log same. Also
   log a WARNING if staging_front and staging_back have identical content
   (indicates the back buffer inherited stale front data after swap, which
   means glyphs written between frames are lost on alternating frames).

4. **renderer.v `commit()`** — Add a key diagnostic: after swap in async
   path, check if staging_back (now the old front) contains data that
   differs from staging_front (now the old back with new writes). If
   staging_back is stale (hasn't been updated since last swap), log
   "DIAG: back buffer stale — frame N glyphs will be missing from
   frame N+2 upload".

Keep all logging behind `$if diag ?` so zero overhead in normal builds.
Format: `eprintln('[DIAG] ...')` for easy grep.

After adding instrumentation, run `v fmt -w glyph_atlas.v` and
`v fmt -w renderer.v`, then `v -check-syntax glyph_atlas.v` and
`v -check-syntax renderer.v`.
  </action>
  <verify>
`v -check-syntax glyph_atlas.v` and `v -check-syntax renderer.v` pass.
`v test .` passes (no regressions). Normal build (no -d diag) produces
no diagnostic output.
  </verify>
  <done>
Diagnostic logging exists behind $if diag in swap_staging_buffers,
reset_page, and commit. Syntax checks pass. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add automated scroll stress mode to stress_demo</name>
  <files>examples/stress_demo.v</files>
  <action>
Modify stress_demo.v to support two diagnostic modes via compile flags:

1. **`-d diag` flag:** Enable automated rapid scroll pattern in frame().
   Every 10 frames, toggle scroll_y between 0 and max_scroll. This
   produces rapid full-range scrolling that triggers viewport culling
   changes and potential LRU eviction (6000 glyphs across scroll range
   exceeds atlas capacity during rapid traversal).

   Add frame_count field to AppStress struct (mut, int, default 0).
   Increment in frame() after rendering.

   Add the scroll automation block:
   ```
   $if diag ? {
       app.frame_count++
       if app.frame_count % 10 == 0 {
           app.scroll_y = if app.scroll_y < app.max_scroll / 2 {
               app.max_scroll
           } else {
               f32(0)
           }
       }
   }
   ```

2. **`-d diag_sync` flag:** After init, disable async uploads:
   In init(), after creating text system, add:
   ```
   $if diag_sync ? {
       // Kill switch: force sync upload path to isolate Phase 27
       app.ts.renderer.atlas.async_uploads = false
   }
   ```
   Note: set_async_uploads is profile-only. Access the field directly
   since stress_demo imports vglyph and the field is pub mut.

After changes, run `v fmt -w examples/stress_demo.v` and
`v -check-syntax examples/stress_demo.v`.
  </action>
  <verify>
`v -check-syntax examples/stress_demo.v` passes.
`v -d diag run examples/stress_demo.v` launches and shows automated
rapid scrolling (visible scroll jumps every ~10 frames).
`v -d diag -d diag_sync run examples/stress_demo.v` launches with sync
upload path (no async).
  </verify>
  <done>
stress_demo has automated scroll via -d diag and sync kill switch via
-d diag_sync. Both compile and run.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run kill switch comparison and capture diagnostic output</name>
  <files>examples/stress_demo.v</files>
  <action>
Run the diagnostic builds and capture output. This is the key empirical
test:

1. **Async mode (default):** Run for ~5 seconds:
   `v -d diag run examples/stress_demo.v 2>&1 | head -200`
   Observe: Does diagnostic output show buffer state issues? Look for
   "stale" warnings, reset_page logging, buffer identity warnings.

2. **Sync mode:** Run for ~5 seconds:
   `v -d diag -d diag_sync run examples/stress_demo.v 2>&1 | head -200`
   Observe: Does diagnostic output differ? Are "stale" warnings absent?

3. **Analysis:** Compare the two runs. Key questions:
   - Do [DIAG] warnings appear in async but not sync? → Phase 27 root
   - Do atlas resets correlate with scroll jumps? → LRU thrashing
   - Are buffers identical after swap? → Double-buffer data loss

Note: The demo windows need to be closed manually or will timeout. Use
timeout command or Ctrl+C after ~5 seconds. If the process doesn't
produce stderr output within a few seconds, the diagnostic code path
may not be hit — adjust frame count threshold or scroll pattern.

If builds fail due to accessing renderer.atlas.async_uploads (field
access across module boundary), use an alternative approach: add a
pub method `set_async_uploads_diag` to api.v that sets the flag
without requiring -d profile. Keep it minimal:
```v
pub fn (mut ts TextSystem) set_async_uploads_diag(enabled bool) {
    ts.renderer.atlas.async_uploads = enabled
}
```
  </action>
  <verify>
Both async and sync diagnostic runs produce output. The comparison
reveals whether symptoms are isolated to async path (Phase 27) or
present in both paths (Phase 26/28).
  </verify>
  <done>
Diagnostic comparison run completed. Evidence captured showing which
path triggers symptoms. Kill switch result documented (async-only vs
both-paths).
  </done>
</task>

</tasks>

<verification>
1. `v test .` passes — no regressions from instrumentation
2. `v -d diag run examples/stress_demo.v` shows automated scroll and
   diagnostic output
3. `v -d diag -d diag_sync run examples/stress_demo.v` shows sync mode
   diagnostic output
4. Comparison data exists to feed into Plan 02 root cause documentation
</verification>

<success_criteria>
- Instrumentation compiles and produces diagnostic output
- Automated scroll reliably triggers scroll range traversal
- Kill switch comparison shows clear async vs sync difference
- Evidence sufficient to determine root cause subsystem
</success_criteria>

<output>
After completion, create `.planning/phases/30-diagnosis/30-01-SUMMARY.md`
</output>
