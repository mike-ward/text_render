---
phase: 21-multi-display-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - ime_bridge_macos.m
  - ime_overlay_darwin.m
autonomous: true

must_haves:
  truths:
    - "Korean IME responds on first keypress (not just second)"
    - "Japanese and Chinese IME continue working on first keypress"
    - "All CJK IMEs work after app launch without manual focus tricks"
  artifacts:
    - path: "ime_bridge_macos.m"
      provides: "Korean IME pre-warm or fix"
      contains: "Korean"
    - path: "ime_overlay_darwin.m"
      provides: "Korean IME pre-warm or fix"
      contains: "Korean"
  key_links:
    - from: "ime_bridge_macos.m"
      to: "NSTextInputContext"
      via: "activation/pre-warming"
      pattern: "activate|Korean"
---

<objective>
Fix Korean IME first-keypress issue

Purpose: Korean composition currently works on SECOND keypress, not first. Japanese and Chinese
work on first keypress. This is a hard requirement per CONTEXT.md - must fix, not document.

Output: Korean IME works on first keypress like Japanese/Chinese
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-multi-display-polish/21-RESEARCH.md
@.planning/phases/20-korean-keyboard/20-RESEARCH.md

@ime_bridge_macos.m
@ime_overlay_darwin.m
</context>

<tasks>

<task type="auto">
  <name>Task 1: Investigate Korean IME initialization timing</name>
  <files>ime_bridge_macos.m, ime_overlay_darwin.m</files>
  <action>
Research suggests Korean IME first-keypress issue is system-level (reported in Qt, Godot,
Alacritty with Apple FB17460926). RESEARCH.md Q5 suggests pre-warming NSTextInputContext.

Investigate current initialization:

1. Check +load timing in ime_bridge_macos.m (line 181-203):
   - Protocol conformance added in +load (early, good)
   - Swizzling done lazily in ensureSwizzling() (may be issue)

2. Check inputContext getter (line 208-221):
   - Creates g_input_context lazily on first access
   - Calls ensureSwizzling() before creating context

3. Check becomeFirstResponder in ime_overlay_darwin.m (line 226-233):
   - Already calls [[self inputContext] activate] on focus

Problem hypothesis: Korean IME requires input context to exist BEFORE first keypress. Current
lazy initialization may be too late for Korean IME internal state.

Try these fixes in order (stop when one works):

**Attempt 1: Pre-create input context in +load**

In ime_bridge_macos.m +load method, after adding protocol conformance, trigger input context
creation by calling dispatch_async to main queue:

```objc
dispatch_async(dispatch_get_main_queue(), ^{
    // Pre-warm IME by creating a dummy context
    // This may initialize Korean IME internal state
    Class viewClass = [NSView class];
    NSView* dummyView = [[viewClass alloc] init];
    NSTextInputContext* ctx = [[NSTextInputContext alloc] initWithClient:(id<NSTextInputClient>)dummyView];
    [ctx activate];
    [ctx deactivate];
    // Don't store - just warming up the system
});
```

**Attempt 2: Force activate on every keyDown**

In vglyph_keyDown function (line 106), before interpretKeyEvents, explicitly activate:

```objc
NSTextInputContext* ctx = [self inputContext];
if (ctx) {
    [ctx activate];
    [ctx discardMarkedText]; // Clear any stale state
}
```

**Attempt 3: Call handleEvent before interpretKeyEvents**

Some apps report success calling handleEvent explicitly:

```objc
NSTextInputContext* ctx = [self inputContext];
if (ctx && [ctx handleEvent:event]) {
    g_ime_handled_key = YES;
    return;
}
// Fall through to interpretKeyEvents
```

Document which attempt (if any) fixed the issue. If none work, implement the most promising
partial improvement and document remaining limitation.
  </action>
  <verify>
After each attempt:
1. Build: v examples/editor_demo.v
2. Run editor_demo
3. Switch to Korean IME (Cmd+Space or menu bar)
4. Click in text area
5. Press 'ㄱ' key (g on QWERTY) - should show Korean character immediately
6. Press 'ㅏ' key (k on QWERTY) - should show '가'

Success = Korean shows on FIRST keypress, not requiring second keypress.
  </verify>
  <done>
Korean IME first-keypress either fixed or best-effort improvement with documented limitation
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply fix to ime_overlay_darwin.m if needed</name>
  <files>ime_overlay_darwin.m</files>
  <action>
If Task 1 found a working fix, apply equivalent changes to ime_overlay_darwin.m.

The overlay API is the preferred long-term approach (per-overlay callbacks vs global).
Ensure both code paths have the same Korean IME fix.

If Task 1 fix was in:
- +load: No changes needed for overlay (overlay created per-instance, not at +load)
- keyDown: Apply same pattern to overlay's keyDown method (line 189-199)
- becomeFirstResponder: Already has activate call, may need discardMarkedText

If no fix found: Ensure overlay has same workarounds as bridge for consistency.
  </action>
  <verify>
If fix found: Run same manual test with overlay API (requires native handle access, may need
temporary test code).

If no fix: Document that both code paths have same behavior.
  </verify>
  <done>
Both ime_bridge_macos.m and ime_overlay_darwin.m have consistent Korean IME handling
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. Build succeeds: v examples/editor_demo.v
2. Run editor_demo
3. Test Korean IME first-keypress behavior
4. Test Japanese IME still works (regression check)
5. Test Chinese IME still works (regression check)
</verification>

<success_criteria>
- Korean IME works on first keypress OR
- Best-effort improvement applied with documented remaining limitation
- Japanese and Chinese IME not regressed
- Both bridge files have consistent handling
</success_criteria>

<output>
After completion, create `.planning/phases/21-multi-display-polish/21-02-SUMMARY.md`

Important: Document whether Korean first-keypress was FIXED or remains a KNOWN ISSUE with
improvement. If known issue, document the specific workaround for users.
</output>
