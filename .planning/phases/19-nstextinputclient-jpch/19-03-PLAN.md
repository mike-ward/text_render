---
phase: 19-nstextinputclient-jpch
plan: 03
type: execute
wave: 3
depends_on: ["19-02"]
files_modified:
  - composition.v
  - renderer.v
  - examples/editor_demo.v
autonomous: true

must_haves:
  truths:
    - "on_marked_text callback updates CompositionState.preedit_text and cursor_offset"
    - "on_insert_text callback commits composition and inserts text to TextBuffer"
    - "on_unmark_text callback cancels composition without inserting"
    - "Preedit text renders at ~70% opacity (dimmed)"
    - "Cursor visible at insertion point within preedit"
    - "Thick underline drawn for selected clause, thin for others"
  artifacts:
    - path: "composition.v"
      provides: "IME callback handler methods"
      contains: "handle_marked_text"
    - path: "renderer.v"
      provides: "Preedit rendering with opacity and clause underlines"
      contains: "draw_composition"
    - path: "examples/editor_demo.v"
      provides: "IME callback registration and wiring"
      contains: "ime_overlay_register_callbacks"
  key_links:
    - from: "examples/editor_demo.v"
      to: "ime_overlay_register_callbacks"
      via: "callback registration on init"
      pattern: "ime_overlay_register_callbacks"
    - from: "on_marked_text callback"
      to: "CompositionState.set_marked_text"
      via: "handler function"
      pattern: "composition\\.set_marked_text"
    - from: "renderer.draw_composition"
      to: "CompositionState.get_clause_rects"
      via: "clause rect iteration"
      pattern: "get_clause_rects"
---

<objective>
Implement V-side CompositionState callback handlers and preedit rendering with visual styling.

Purpose: Complete the IME integration by consuming C callbacks and rendering preedit properly.
Output: Working Japanese/Chinese input with visual feedback (opacity, cursor, underlines).
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-nstextinputclient-jpch/19-CONTEXT.md
@.planning/phases/19-nstextinputclient-jpch/19-01-SUMMARY.md
@.planning/phases/19-nstextinputclient-jpch/19-02-SUMMARY.md

@composition.v
@renderer.v
@c_bindings.v
@examples/editor_demo.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement IME callback handlers in CompositionState</name>
  <files>composition.v</files>
  <action>
Add callback handler methods to CompositionState that can be registered with overlay:

```v
// handle_marked_text processes setMarkedText from IME overlay.
// Called from C callback, updates preedit_text and cursor_offset.
// Starts composition if not already active.
pub fn (mut cs CompositionState) handle_marked_text(text string, cursor_in_preedit int,
    document_cursor int) {
    if !cs.is_composing() {
        cs.start(document_cursor)
    }
    cs.set_marked_text(text, cursor_in_preedit)
}

// handle_insert_text processes insertText from IME overlay.
// Commits composition and returns text to insert into document.
// Returns empty string if not composing.
pub fn (mut cs CompositionState) handle_insert_text(text string) string {
    if cs.is_composing() {
        cs.cancel()  // Clear composition state
    }
    return text  // Return committed text for insertion
}

// handle_unmark_text processes unmarkText from IME overlay.
// Cancels composition without committing any text.
pub fn (mut cs CompositionState) handle_unmark_text() {
    cs.cancel()
}

// handle_clause processes clause info from IME overlay.
// Accumulates clauses; call clear_clauses before enumeration.
pub fn (mut cs CompositionState) handle_clause(start int, length int, style int) {
    clause_style := match style {
        2 { ClauseStyle.selected }
        1 { ClauseStyle.converted }
        else { ClauseStyle.raw }
    }
    cs.clauses << Clause{
        start:  start
        length: length
        style:  clause_style
    }
}

// clear_clauses resets clause array for fresh enumeration
pub fn (mut cs CompositionState) clear_clauses() {
    cs.clauses.clear()
    cs.selected_clause = -1
}
```

These methods translate C callback data into CompositionState updates.
  </action>
  <verify>
grep finds `handle_marked_text` in composition.v
grep finds `handle_insert_text` in composition.v
grep finds `handle_clause` in composition.v
`v -check-syntax composition.v` passes
  </verify>
  <done>
CompositionState has handler methods for all IME callbacks
  </done>
</task>

<task type="auto">
  <name>Task 2: Add preedit rendering with opacity and clause underlines</name>
  <files>renderer.v</files>
  <action>
Add draw_composition method to Renderer for preedit visual feedback:

```v
// draw_composition renders IME preedit text with visual feedback.
// Per CONTEXT.md decisions:
// - Preedit at ~70% opacity (alpha 178)
// - Cursor visible at insertion point within preedit
// - Thick underline for selected clause, thin for others
pub fn (mut renderer Renderer) draw_composition(layout Layout, x f32, y f32,
    cs &CompositionState, cursor_color gg.Color) {
    if !cs.is_composing() {
        return
    }

    // Draw clause underlines
    clause_rects := cs.get_clause_rects(layout)
    for cr in clause_rects {
        // Underline thickness: 2px for selected, 1px for others
        thickness := if cr.style == .selected { f32(2.0) } else { f32(1.0) }

        for rect in cr.rects {
            // Draw underline at bottom of rect
            underline_y := rect.y + rect.height - thickness
            // Use cursor color for underlines (dimmed like preedit)
            underline_color := gg.Color{
                r: cursor_color.r
                g: cursor_color.g
                b: cursor_color.b
                a: 178  // ~70% opacity
            }
            renderer.ctx.draw_rect_filled(
                rect.x + x,
                underline_y + y,
                rect.width,
                thickness,
                underline_color
            )
        }
    }

    // Draw cursor at insertion point within preedit
    cursor_pos := cs.get_document_cursor_pos()
    if cursor_rect := layout.get_cursor_pos(cursor_pos, false) {
        // Draw cursor at ~70% opacity
        dimmed_cursor := gg.Color{
            r: cursor_color.r
            g: cursor_color.g
            b: cursor_color.b
            a: 178
        }
        renderer.ctx.draw_rect_filled(
            cursor_rect.x + x,
            cursor_rect.y + y,
            f32(2.0),  // cursor width
            cursor_rect.height,
            dimmed_cursor
        )
    }
}

// draw_layout_with_composition renders layout with preedit opacity applied.
// Preedit text range gets alpha reduced to ~70%.
// Call this instead of draw_layout when composition is active.
pub fn (mut renderer Renderer) draw_layout_with_composition(layout Layout, x f32, y f32,
    cs &CompositionState) {
    // For now, draw normally - preedit opacity would require layout item modification
    // or shader support. The underlines provide sufficient visual distinction.
    // Full opacity reduction deferred to future enhancement.
    renderer.draw_layout(layout, x, y)
}
```

Note: Full preedit opacity requires modifying layout items or shader support. For MVP, underlines
provide visual distinction. Opacity can be added when layout items support per-character alpha.
  </action>
  <verify>
grep finds `draw_composition` in renderer.v
grep finds `get_clause_rects` call in draw_composition
grep finds thickness comparison for `.selected`
`v -check-syntax renderer.v` passes
  </verify>
  <done>
Renderer has draw_composition method with clause underlines and cursor rendering
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire IME callbacks in editor_demo</name>
  <files>examples/editor_demo.v</files>
  <action>
Register IME callbacks in editor_demo to connect overlay to CompositionState:

1. Add callback functions (module-level or as methods):

```v
// IME callback handlers - called from C overlay
fn ime_on_marked_text(text &char, cursor_pos int, user_data voidptr) {
    mut state := unsafe { &EditorState(user_data) }
    text_str := unsafe { cstring_to_vstring(text) }
    state.composition.handle_marked_text(text_str, cursor_pos, state.cursor_idx)
    state.rebuild_layout()
}

fn ime_on_insert_text(text &char, user_data voidptr) {
    mut state := unsafe { &EditorState(user_data) }
    text_str := unsafe { cstring_to_vstring(text) }
    committed := state.composition.handle_insert_text(text_str)
    if committed.len > 0 {
        state.buffer.insert(state.cursor_idx, committed)
        state.cursor_idx += committed.len
        state.rebuild_layout()
    }
}

fn ime_on_unmark_text(user_data voidptr) {
    mut state := unsafe { &EditorState(user_data) }
    state.composition.handle_unmark_text()
    state.rebuild_layout()
}

fn ime_on_get_bounds(user_data voidptr, x &f32, y &f32, w &f32, h &f32) bool {
    state := unsafe { &EditorState(user_data) }
    if rect := state.composition.get_composition_bounds(state.layout) {
        unsafe {
            *x = rect.x
            *y = rect.y
            *w = rect.width
            *h = rect.height
        }
        return true
    }
    return false
}

fn ime_on_clauses_begin(user_data voidptr) {
    mut state := unsafe { &EditorState(user_data) }
    state.composition.clear_clauses()
}

fn ime_on_clause(start int, length int, style int, user_data voidptr) {
    mut state := unsafe { &EditorState(user_data) }
    state.composition.handle_clause(start, length, style)
}

fn ime_on_clauses_end(user_data voidptr) {
    // No action needed - clauses already accumulated
}
```

2. In init or after overlay creation, register callbacks:

```v
// Register IME callbacks (after overlay handle obtained)
vglyph.ime_overlay_register_callbacks(
    overlay_handle,
    ime_on_marked_text,
    ime_on_insert_text,
    ime_on_unmark_text,
    ime_on_get_bounds,
    ime_on_clauses_begin,
    ime_on_clause,
    ime_on_clauses_end,
    voidptr(state)
)
```

3. Update draw function to use draw_composition:

```v
// In frame callback, after draw_layout:
if state.composition.is_composing() {
    state.renderer.draw_composition(state.layout, text_x, text_y,
        &state.composition, cursor_color)
}
```

4. Remove or update existing manual IME handling that conflicts with callback-based approach.
  </action>
  <verify>
grep finds `ime_overlay_register_callbacks` in editor_demo.v
grep finds `ime_on_marked_text` function definition
grep finds `draw_composition` call
`v -check-syntax examples/editor_demo.v` passes
  </verify>
  <done>
editor_demo registers IME callbacks and uses draw_composition for preedit rendering
  </done>
</task>

</tasks>

<verification>
1. Build verification:
   - `v -check-syntax composition.v`
   - `v -check-syntax renderer.v`
   - `v -check-syntax examples/editor_demo.v`
   - `v build examples/editor_demo.v` compiles

2. Callback wiring:
   - ime_overlay_register_callbacks called with all callback functions
   - Callbacks update CompositionState correctly

3. Visual rendering:
   - draw_composition called during composition
   - Clause underlines drawn (thick for selected, thin for others)
   - Cursor drawn at preedit insertion point

4. Integration:
   - Japanese IME: type romaji, see hiragana preedit, select kanji, commit
   - Chinese IME: type pinyin, see preedit, select character, commit
</verification>

<success_criteria>
- CompositionState handler methods process IME callbacks correctly
- Callback registration connects overlay to CompositionState
- Preedit displays with underlines indicating clause boundaries
- Selected clause has thick underline, others have thin
- Cursor visible within preedit at correct position
- Committed text inserted into TextBuffer at cursor position
- Cancel (unmark) discards preedit without insertion
</success_criteria>

<output>
After completion, create `.planning/phases/19-nstextinputclient-jpch/19-03-SUMMARY.md`
</output>
