---
phase: 19-nstextinputclient-jpch
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - ime_overlay_darwin.h
  - ime_overlay_darwin.m
  - c_bindings.v
autonomous: true

must_haves:
  truths:
    - "firstRectForCharacterRange invokes on_get_bounds callback and transforms to screen coords"
    - "Clause attributes extracted from NSAttributedString underline styles"
    - "on_clause callback invoked for each clause segment with style mapping"
    - "Out-of-bounds ranges return NSZeroRect (no crash)"
  artifacts:
    - path: "ime_overlay_darwin.m"
      provides: "firstRectForCharacterRange with screen coord transform"
      contains: "convertRectToScreen"
    - path: "ime_overlay_darwin.h"
      provides: "Bounds and clause callback declarations"
      contains: "on_get_bounds"
    - path: "c_bindings.v"
      provides: "V bounds and clause callback registration"
      contains: "IMEOverlayBoundsCallback"
  key_links:
    - from: "ime_overlay_darwin.m"
      to: "VGlyphIMECallbacks.on_get_bounds"
      via: "bounds callback invocation"
      pattern: "callbacks\\.on_get_bounds"
    - from: "firstRectForCharacterRange"
      to: "screen coordinates"
      via: "convertRectToScreen"
      pattern: "convertRectToScreen"
    - from: "setMarkedText"
      to: "on_clause"
      via: "NSUnderlineStyleAttributeName enumeration"
      pattern: "on_clause"
---

<objective>
Implement coordinate bridge for candidate window positioning and clause attribute parsing.

Purpose: Enable IME candidate window to appear near cursor; extract clause info for V-side use.
Output: Working firstRectForCharacterRange with screen transforms, clause data extraction.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-nstextinputclient-jpch/19-CONTEXT.md
@.planning/phases/19-nstextinputclient-jpch/19-RESEARCH.md
@.planning/phases/19-nstextinputclient-jpch/19-01-SUMMARY.md

@ime_overlay_darwin.h
@ime_overlay_darwin.m
@c_bindings.v
@composition.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bounds callback to VGlyphIMECallbacks</name>
  <files>ime_overlay_darwin.h, ime_overlay_darwin.m, ime_overlay_stub.c, c_bindings.v</files>
  <action>
Extend VGlyphIMECallbacks in ime_overlay_darwin.h:

```c
typedef struct {
    void (*on_marked_text)(const char* text, int cursor_pos, void* user_data);
    void (*on_insert_text)(const char* text, void* user_data);
    void (*on_unmark_text)(void* user_data);
    // NEW: Get bounds for composition text
    // Returns true if bounds valid, fills x/y/width/height in VIEW coordinates
    bool (*on_get_bounds)(void* user_data, float* x, float* y, float* width, float* height);
    void* user_data;
} VGlyphIMECallbacks;
```

In c_bindings.v, update:
1. C.VGlyphIMECallbacks struct to include `on_get_bounds`
2. Add callback type: `type IMEOverlayBoundsCallback = fn (user_data voidptr, x &f32, y &f32,
   w &f32, h &f32) bool`
3. Update `ime_overlay_register_callbacks` to accept bounds callback

Update ime_overlay_stub.c if needed (callback struct change is header-only).
  </action>
  <verify>
grep finds `on_get_bounds` in ime_overlay_darwin.h
`v -check-syntax c_bindings.v` passes
  </verify>
  <done>
Bounds callback added to callback structure, V bindings updated
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement firstRectForCharacterRange with screen transform</name>
  <files>ime_overlay_darwin.m</files>
  <action>
Implement `firstRectForCharacterRange:actualRange:` per RESEARCH.md patterns:

```objc
- (NSRect)firstRectForCharacterRange:(NSRange)range
                         actualRange:(nullable NSRangePointer)actualRange {
    // Clamp range to valid bounds (Pitfall #4)
    if (range.location == NSNotFound) {
        return NSZeroRect;
    }

    // Call V callback to get bounds in view coordinates
    if (!_callbacks.on_get_bounds) {
        return NSZeroRect;
    }

    float x, y, w, h;
    bool valid = _callbacks.on_get_bounds(_callbacks.user_data, &x, &y, &w, &h);
    if (!valid) {
        return NSZeroRect;
    }

    if (actualRange) {
        *actualRange = _markedRange.location != NSNotFound ? _markedRange : range;
    }

    // V gives view-local coords; transform to screen (Pitfall #2)
    // Note: macOS origin is bottom-left, VGlyph origin is top-left
    // Need to flip Y coordinate
    NSRect viewRect = NSMakeRect(x, self.bounds.size.height - y - h, w, h);

    // Transform: view -> window -> screen
    NSRect windowRect = [self convertRect:viewRect toView:nil];
    NSRect screenRect = [[self window] convertRectToScreen:windowRect];

    return screenRect;
}
```

Key points:
- Call on_get_bounds callback to get rect from V (view coords, top-left origin)
- Flip Y for macOS bottom-left origin
- Use convertRect:toView:nil then convertRectToScreen for proper transform
- Return NSZeroRect on invalid/missing data (not crash)
  </action>
  <verify>
grep finds `convertRectToScreen` in firstRectForCharacterRange
grep finds `on_get_bounds` call
grep finds `self.bounds.size.height - y - h` (Y flip)
  </verify>
  <done>
firstRectForCharacterRange returns screen coordinates for candidate window positioning
  </done>
</task>

<task type="auto">
  <name>Task 3: Parse NSAttributedString underline attributes for clause info</name>
  <files>ime_overlay_darwin.h, ime_overlay_darwin.m, c_bindings.v</files>
  <action>
Add clause callback to VGlyphIMECallbacks:

```c
// ime_overlay_darwin.h
typedef struct {
    // ... existing callbacks ...
    // NEW: Report clause segmentation from IME
    // style: 0=raw, 1=converted, 2=selected (matches ClauseStyle enum)
    void (*on_clause)(int start, int length, int style, void* user_data);
    void (*on_clauses_begin)(void* user_data);  // Called before clause enumeration
    void (*on_clauses_end)(void* user_data);    // Called after all clauses reported
    void* user_data;
} VGlyphIMECallbacks;
```

In setMarkedText, after extracting text, parse attributes:

```objc
// Parse underline attributes for clause segmentation
if ([string isKindOfClass:[NSAttributedString class]]) {
    NSAttributedString* attrString = (NSAttributedString*)string;

    if (_callbacks.on_clauses_begin) {
        _callbacks.on_clauses_begin(_callbacks.user_data);
    }

    [attrString enumerateAttribute:NSUnderlineStyleAttributeName
                           inRange:NSMakeRange(0, attrString.length)
                           options:0
                        usingBlock:^(id value, NSRange range, BOOL *stop) {
        if (value && _callbacks.on_clause) {
            NSUnderlineStyle style = [value integerValue];
            // Map: NSUnderlineStyleThick = selected, others = raw/converted
            int clauseStyle = (style == NSUnderlineStyleThick) ? 2 : 0;
            _callbacks.on_clause((int)range.location, (int)range.length,
                                 clauseStyle, _callbacks.user_data);
        }
    }];

    if (_callbacks.on_clauses_end) {
        _callbacks.on_clauses_end(_callbacks.user_data);
    }
}
```

Update c_bindings.v:
1. Add callback types for clause reporting
2. Update C.VGlyphIMECallbacks struct
3. Update ime_overlay_register_callbacks function signature

Per CONTEXT.md: thick underline = selected clause, thin = unselected.
  </action>
  <verify>
grep finds `NSUnderlineStyleAttributeName` in ime_overlay_darwin.m
grep finds `on_clause` callback invocation
grep finds `NSUnderlineStyleThick` comparison
`v -check-syntax c_bindings.v` passes
  </verify>
  <done>
Clause attributes extracted from NSAttributedString, reported via callbacks to V
  </done>
</task>

</tasks>

<verification>
1. Build verification:
   - `clang -c -fobjc-arc -framework Cocoa ime_overlay_darwin.m -o /dev/null`
   - `v -check-syntax c_bindings.v`

2. Coordinate transform chain:
   - on_get_bounds callback invoked
   - Y coordinate flipped for macOS origin
   - convertRect:toView:nil followed by convertRectToScreen

3. Clause parsing:
   - NSAttributedString enumerated for NSUnderlineStyleAttributeName
   - Thick underline maps to selected (2), others to raw (0)
   - on_clauses_begin/on_clause/on_clauses_end sequence

4. Safety:
   - NSZeroRect returned for invalid ranges
   - NULL callback checks before invocation
</verification>

<success_criteria>
- firstRectForCharacterRange invokes on_get_bounds and returns screen coordinates
- Y coordinate properly flipped (top-left VGlyph -> bottom-left macOS)
- Clause underline attributes extracted from NSAttributedString
- Thick underline = selected clause style (2)
- Out-of-bounds ranges return NSZeroRect (no crash)
- All V bindings compile and match C header
</success_criteria>

<output>
After completion, create `.planning/phases/19-nstextinputclient-jpch/19-02-SUMMARY.md`
</output>
