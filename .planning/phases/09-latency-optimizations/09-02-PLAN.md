---
phase: 09-latency-optimizations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [context.v, renderer.v, glyph_atlas.v]
autonomous: true

must_haves:
  truths:
    - "Font metrics cached by (face, size) tuple"
    - "Metrics cache uses LRU eviction at 256 entries"
    - "Glyph cache validates secondary key in debug builds"
    - "Collision stats tracked in profile builds"
  artifacts:
    - path: "context.v"
      provides: "MetricsCache struct with LRU"
      contains: "struct MetricsCache"
    - path: "renderer.v"
      provides: "Secondary key validation in get_or_load_glyph"
      contains: "font_face.*glyph_index"
    - path: "glyph_atlas.v"
      provides: "CachedGlyph with secondary key fields"
      contains: "font_face.*voidptr"
  key_links:
    - from: "context.v"
      to: "context.v font_metrics()"
      via: "metrics_cache.get/put"
      pattern: "metrics_cache"
---

<objective>
Implement metrics caching (LATENCY-02) and glyph cache collision detection (LATENCY-03).

Purpose: Reduce FreeType FFI calls via font metrics cache. Detect hash collisions that would
corrupt glyph rendering by validating secondary key in debug builds.

Output: MetricsCache with 256-entry LRU, CachedGlyph stores secondary key, debug assertion
on collision mismatch.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-latency-optimizations/09-CONTEXT.md
@.planning/phases/09-latency-optimizations/09-RESEARCH.md
@context.v
@renderer.v
@glyph_atlas.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MetricsCache with LRU eviction</name>
  <files>context.v</files>
  <action>
Add MetricsCache struct with simple LRU implementation:

```v
struct FontMetricsEntry {
    ascent  int   // Pango units
    descent int   // Pango units
    linegap int   // Pango units (0 if not available)
}

struct MetricsCache {
mut:
    entries      map[u64]FontMetricsEntry
    access_order []u64  // Most recent at end
    capacity     int = 256
    // Profile fields
    hits   int
    misses int
}

fn (mut cache MetricsCache) get(key u64) ?FontMetricsEntry {
    if key in cache.entries {
        $if profile ? {
            cache.hits++
        }
        // Move to end (most recent)
        cache.access_order = cache.access_order.filter(it != key)
        cache.access_order << key
        return cache.entries[key]
    }
    $if profile ? {
        cache.misses++
    }
    return none
}

fn (mut cache MetricsCache) put(key u64, entry FontMetricsEntry) {
    if cache.entries.len >= cache.capacity && key !in cache.entries {
        // Evict oldest (first in access_order)
        if cache.access_order.len > 0 {
            evict_key := cache.access_order[0]
            cache.entries.delete(evict_key)
            cache.access_order.delete(0)
        }
    }
    cache.entries[key] = entry
    // Remove existing position if present, add to end
    cache.access_order = cache.access_order.filter(it != key)
    cache.access_order << key
}
```

Add metrics_cache field to Context struct:

```v
pub struct Context {
    // ... existing fields
mut:
    metrics_cache MetricsCache
}
```

Key computation: `u64(voidptr(face)) ^ (u64(size_pango_units) << 32)`

In new_context(), initialize metrics_cache with capacity 256 (default).
  </action>
  <verify>
`v -check-syntax context.v` passes.
`v fmt -w context.v` formats.
  </verify>
  <done>
MetricsCache struct with LRU eviction at 256 entries, integrated into Context.
  </done>
</task>

<task type="auto">
  <name>Task 2: Use metrics cache in font_metrics() and font_height()</name>
  <files>context.v</files>
  <action>
Modify font_height() to check cache first:

```v
pub fn (mut ctx Context) font_height(cfg TextConfig) f32 {
    desc := ctx.create_font_description(cfg.style)
    if desc == unsafe { nil } {
        return 0
    }
    defer { C.pango_font_description_free(desc) }

    // Get font to extract face pointer for cache key
    font := C.pango_context_load_font(ctx.pango_context, desc)
    if font == unsafe { nil } {
        return 0
    }
    defer { C.g_object_unref(font) }

    face := C.pango_ft2_font_get_face(font)
    size_units := C.pango_font_description_get_size(desc)
    cache_key := u64(voidptr(face)) ^ (u64(size_units) << 32)

    // Check cache
    if entry := ctx.metrics_cache.get(cache_key) {
        return (f32(entry.ascent + entry.descent) / f32(pango_scale)) / ctx.scale_factor
    }

    // Cache miss: fetch from Pango
    language := C.pango_language_get_default()
    metrics := C.pango_font_get_metrics(font, language)
    if metrics == unsafe { nil } {
        return 0
    }
    defer { C.pango_font_metrics_unref(metrics) }

    ascent := C.pango_font_metrics_get_ascent(metrics)
    descent := C.pango_font_metrics_get_descent(metrics)

    // Store in cache
    ctx.metrics_cache.put(cache_key, FontMetricsEntry{
        ascent:  ascent
        descent: descent
        linegap: 0
    })

    return (f32(ascent + descent) / f32(pango_scale)) / ctx.scale_factor
}
```

Similarly update font_metrics() to use cache:

```v
pub fn (mut ctx Context) font_metrics(cfg TextConfig) TextMetrics {
    // Same pattern: check cache first, fetch and cache on miss
    // Return TextMetrics from cached FontMetricsEntry
}
```

Note: font_height() and font_metrics() share the same cache since they need same data.
  </action>
  <verify>
`v -check-syntax context.v` passes.
`v test .` - existing tests pass (font_metrics tests).
  </verify>
  <done>
font_height() and font_metrics() use MetricsCache, reducing Pango/FreeType calls.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add secondary key validation to glyph cache</name>
  <files>glyph_atlas.v, renderer.v</files>
  <action>
Extend CachedGlyph with secondary key fields (glyph_atlas.v):

```v
pub struct CachedGlyph {
pub:
    x      int
    y      int
    width  int
    height int
    left   int
    top    int
    page   int   // From Plan 01 (if running after), else add it here
    // Secondary key for collision detection
    font_face     voidptr
    glyph_index   u32
    subpixel_bin  u8
}
```

Update insert_bitmap() signature to accept secondary key fields, or pass through from
load_glyph() where we have access to the face/index/bin.

In renderer.v get_or_load_glyph():

```v
fn (mut renderer Renderer) get_or_load_glyph(item Item, glyph Glyph, bin int) !CachedGlyph {
    if item.ft_face == unsafe { nil } {
        return error('Invalid font face')
    }
    font_id := u64(voidptr(item.ft_face))
    index_with_bin := (u64(glyph.index) << 2) | u64(bin)
    key := font_id ^ (index_with_bin << 32)

    if cached := renderer.cache[key] {
        $if profile ? {
            renderer.glyph_cache_hits++
        }

        // Secondary key validation
        $if debug {
            if cached.font_face != voidptr(item.ft_face) ||
               cached.glyph_index != glyph.index ||
               cached.subpixel_bin != u8(bin) {
                panic('Glyph cache collision: key=0x${key:016x} expected face=${voidptr(item.ft_face)} got=${cached.font_face}')
            }
        }

        return cached
    }

    $if profile ? {
        renderer.glyph_cache_misses++
    }

    target_h := int(f32(item.ascent) * renderer.scale_factor)
    mut cached_glyph := renderer.load_glyph(LoadGlyphConfig{
        face:          item.ft_face
        index:         glyph.index
        target_height: target_h
        subpixel_bin:  bin
    })!

    // Set secondary key fields
    cached_glyph = CachedGlyph{
        ...cached_glyph
        font_face:    voidptr(item.ft_face)
        glyph_index:  glyph.index
        subpixel_bin: u8(bin)
    }

    renderer.cache[key] = cached_glyph
    return cached_glyph
}
```

Add collision counter to Renderer (profile only):

```v
pub struct Renderer {
    // ... existing fields
pub mut:
    glyph_cache_collisions int  // Only tracked in profile builds
}
```

Note: Since debug assertion panics on collision, the counter is for evict-and-reload path
if we choose that instead of panic. Per CONTEXT.md: "debug validation: assert on mismatch"
so panic is correct. Counter tracks "near misses" in profile builds (where secondary key
matches but we want stats anyway).
  </action>
  <verify>
`v -check-syntax glyph_atlas.v renderer.v` passes.
`v fmt -w glyph_atlas.v renderer.v` formats.
`v -d debug test .` - tests pass (no collisions expected in normal operation).
  </verify>
  <done>
CachedGlyph stores secondary key, debug builds assert on collision, profile tracks stats.
  </done>
</task>

</tasks>

<verification>
1. Compile: `v -check-syntax *.v` passes
2. Format: `v fmt -w *.v` completes
3. Tests: `v test .` - all existing tests pass
4. Debug build: `v -d debug test .` passes
5. Profile build: `v -d profile examples/stress_demo.v` compiles
</verification>

<success_criteria>
- LATENCY-02 addressed: MetricsCache with 256-entry LRU reduces FreeType calls
- LATENCY-03 addressed: Secondary key validation in debug builds catches collisions
- Cache hit/miss stats available in profile builds
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/09-latency-optimizations/09-02-SUMMARY.md`
</output>
