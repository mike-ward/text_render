---
phase: 09-latency-optimizations
plan: 03
type: execute
wave: 2
depends_on: [09-01]
files_modified: [glyph_atlas.v, renderer.v, bitmap_scaling.v]
autonomous: false

must_haves:
  truths:
    - "Color emoji uploaded at native resolution"
    - "GPU scales emoji via destination rect"
    - "No CPU bicubic scaling for BGRA bitmaps"
    - "Emoji max size clamped to 256x256"
  artifacts:
    - path: "glyph_atlas.v"
      provides: "BGRA path stores native resolution"
      contains: "FT_PIXEL_MODE_BGRA"
    - path: "renderer.v"
      provides: "Emoji scale factor in draw"
      contains: "emoji_scale"
  key_links:
    - from: "glyph_atlas.v ft_bitmap_to_bitmap"
      to: "renderer.v draw_layout"
      via: "CachedGlyph with native dimensions"
      pattern: "scale.*dst"
---

<objective>
Implement GPU-based emoji scaling to eliminate CPU bicubic overhead (LATENCY-04).

Purpose: Current code runs CPU bicubic (16 samples/pixel) on every BGRA emoji bitmap.
GPU scaling uploads native resolution and scales destination rect, using GL_LINEAR sampler.

Output: BGRA bitmaps stored at native size, draw_layout scales destination rect.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-latency-optimizations/09-CONTEXT.md
@.planning/phases/09-latency-optimizations/09-RESEARCH.md
@.planning/phases/09-latency-optimizations/09-01-SUMMARY.md
@glyph_atlas.v
@renderer.v
@bitmap_scaling.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove CPU scaling from BGRA bitmap path</name>
  <files>glyph_atlas.v</files>
  <action>
Modify ft_bitmap_to_bitmap() BGRA case to store native resolution:

```v
u8(C.FT_PIXEL_MODE_BGRA) {
    // Clamp to max texture size per CONTEXT.md decision
    if width > 256 || height > 256 {
        return error('Emoji bitmap exceeds max size 256x256: ${width}x${height}')
    }

    // Copy BGRA to RGBA without scaling
    for y in 0 .. height {
        src_y := if pitch_positive { y } else { height - 1 - y }
        row := unsafe { bmp.buffer + src_y * abs_pitch }
        for x in 0 .. width {
            src := unsafe { row + x * 4 }
            i := (y * width + x) * 4
            data[i + 0] = unsafe { src[2] } // R
            data[i + 1] = unsafe { src[1] } // G
            data[i + 2] = unsafe { src[0] } // B
            data[i + 3] = unsafe { src[3] } // A
        }
    }

    // REMOVED: scale_bitmap_bicubic call
    // Native resolution stored, GPU handles scaling via destination rect
}
```

Remove the target_size calculation and needs_scaling check from BGRA case.
The target_height parameter is still needed for load_glyph but not used for BGRA.

Keep scale_bitmap_bicubic in bitmap_scaling.v for potential future use (don't delete),
but it won't be called from BGRA path anymore.
  </action>
  <verify>
`v -check-syntax glyph_atlas.v` passes.
`v fmt -w glyph_atlas.v` formats.
  </verify>
  <done>
BGRA bitmaps copied at native resolution, no CPU scaling applied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scale emoji destination rect in draw_layout</name>
  <files>renderer.v</files>
  <action>
In draw_layout(), add emoji scaling logic when drawing BGRA glyphs.

The challenge: We need to know if a glyph is emoji (BGRA) to apply GPU scaling.
Options:
1. Add is_emoji flag to CachedGlyph (requires tracking pixel_mode through load_glyph)
2. Detect by checking if glyph uses full color (heuristic: large glyph, has color)
3. Use item.use_original_color as proxy (already set for color glyphs)

Best approach: Use item.use_original_color which is already set for BGRA glyphs.

Modify the glyph drawing section:

```v
if cg.width > 0 && cg.height > 0 {
    mut glyph_w := f32(cg.width) * scale_inv
    mut glyph_h := f32(cg.height) * scale_inv

    // GPU emoji scaling: if color glyph, scale to target ascent
    if item.use_original_color {
        // Target size is the font's ascent (typical emoji sizing)
        target_size := f32(item.ascent)
        native_h := glyph_h  // Already in logical units

        if native_h > 0 && native_h != target_size {
            emoji_scale := target_size / native_h
            glyph_w *= emoji_scale
            glyph_h *= emoji_scale
            // Adjust draw position to account for scaling
            draw_x = (f32(draw_origin_x) + f32(cg.left) * emoji_scale) * scale_inv
            draw_y = (f32(draw_origin_y) - f32(cg.top) * emoji_scale) * scale_inv
        }
    }

    dst := gg.Rect{
        x:      draw_x
        y:      draw_y
        width:  glyph_w
        height: glyph_h
    }
    // ... rest unchanged
}
```

Similarly update draw_layout_rotated() with same scaling logic.

Note: GL_LINEAR sampler already configured in create_linear_sampler() (renderer.v:60-68).
This provides bilinear filtering for scaled emoji - acceptable quality per CONTEXT.md.
  </action>
  <verify>
`v -check-syntax renderer.v` passes.
`v fmt -w renderer.v` formats.
Run emoji example: `v run examples/emoji_demo.v` - emoji render correctly scaled.
  </verify>
  <done>
draw_layout scales emoji via destination rect, GPU handles filtering.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
GPU emoji scaling: BGRA bitmaps stored at native resolution, scaled via destination rect.
Multi-page atlas from Plan 01 should also be integrated.
  </what-built>
  <how-to-verify>
1. Build and run emoji demo:
   ```
   v run examples/emoji_demo.v
   ```

2. Verify emoji render at correct size (should match font height)

3. Verify emoji quality is acceptable (bilinear filtering, not blocky)

4. Build and run stress demo with profiling:
   ```
   v -d profile run examples/stress_demo.v
   ```

5. Verify no atlas resets (multi-page should prevent mid-render resets)

6. Check profile output shows:
   - Multiple atlas pages if stress test fills atlas
   - Cache hit rates
   - No unexpected latency spikes
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. Compile: `v -check-syntax *.v` passes
2. Format: `v fmt -w *.v` completes
3. Tests: `v test .` - all existing tests pass
4. Emoji demo: `v run examples/emoji_demo.v` shows correctly sized emoji
5. Stress test: No mid-frame resets with multi-page atlas
</verification>

<success_criteria>
- LATENCY-04 addressed: GPU scaling eliminates CPU bicubic for emoji
- Emoji render at correct size matching font ascent
- Bilinear filtering provides acceptable quality
- Integration with multi-page atlas works correctly
- All requirements LATENCY-01 through LATENCY-04 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/09-latency-optimizations/09-03-SUMMARY.md`
</output>
