---
phase: 09-latency-optimizations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [glyph_atlas.v, renderer.v, context.v]
autonomous: true

must_haves:
  truths:
    - "Atlas grows to multiple pages instead of resetting when full"
    - "Cache entries track which page they belong to"
    - "Page reset only invalidates entries for that page"
    - "Profile metrics show per-page utilization"
  artifacts:
    - path: "glyph_atlas.v"
      provides: "AtlasPage struct, multi-page GlyphAtlas"
      contains: "struct AtlasPage"
    - path: "renderer.v"
      provides: "Page-aware glyph cache invalidation"
      contains: "cached.page"
  key_links:
    - from: "glyph_atlas.v"
      to: "renderer.v"
      via: "CachedGlyph.page field"
      pattern: "page.*int"
---

<objective>
Implement multi-page texture atlas to eliminate mid-frame reset stalls (LATENCY-01).

Purpose: When single atlas fills, current code resets entire atlas invalidating all cached glyphs.
Multi-page approach adds new pages on demand (up to 4), resetting oldest page only when all full.

Output: GlyphAtlas supports 1-4 pages, CachedGlyph tracks page index, per-page invalidation.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-latency-optimizations/09-CONTEXT.md
@.planning/phases/09-latency-optimizations/09-RESEARCH.md
@glyph_atlas.v
@renderer.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AtlasPage struct and multi-page GlyphAtlas</name>
  <files>glyph_atlas.v</files>
  <action>
Create AtlasPage struct containing per-page state:

```v
struct AtlasPage {
mut:
    image      gg.Image
    width      int
    height     int
    cursor_x   int
    cursor_y   int
    row_height int
    dirty      bool
    age        u64        // Frame counter when last used
    // Profile fields
    used_pixels i64
}
```

Modify GlyphAtlas to hold array of pages:

```v
pub struct GlyphAtlas {
pub mut:
    ctx           &gg.Context
    pages         []AtlasPage
    max_pages     int = 4
    current_page  int
    frame_counter u64
    max_height    int = 4096
    garbage       []int
    // Existing profile fields stay (atlas_inserts, atlas_grows, atlas_resets, etc.)
    // current_atlas_bytes/peak_atlas_bytes now sum across all pages
}
```

Update new_glyph_atlas() to create single page initially (lazy allocation pattern).

Update insert_bitmap() logic:
1. Try current page
2. If full and pages.len < max_pages: create new page, set as current
3. If all 4 pages exist and all full: find oldest (lowest age), reset it, use it

Add helper functions:
- new_atlas_page(ctx, w, h) !AtlasPage
- find_oldest_page() int - returns index of page with lowest age
- reset_page(page_idx int) - clears page cursors, zeros memory

Update grow() to work on specific page (or remove if not needed with multi-page).

Memory tracking: sum current_atlas_bytes across all pages.

Key decision from CONTEXT.md: Start 1 page, max 4, same size as current (1024x1024 initial,
grows to max_height), reset oldest when all full.
  </action>
  <verify>
`v -check-syntax glyph_atlas.v` passes.
`v fmt -w glyph_atlas.v` formats without error.
  </verify>
  <done>
GlyphAtlas holds []AtlasPage, insert_bitmap adds pages on demand up to 4, resets oldest when full.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend CachedGlyph with page index and update renderer</name>
  <files>glyph_atlas.v, renderer.v</files>
  <action>
Add page field to CachedGlyph struct (glyph_atlas.v):

```v
pub struct CachedGlyph {
pub:
    x      int
    y      int
    width  int
    height int
    left   int
    top    int
    page   int   // Which atlas page this glyph is on
}
```

Update insert_bitmap() to return CachedGlyph with correct page index.

Update renderer.v:

1. Modify load_glyph() to propagate page from insert_bitmap result.

2. In get_or_load_glyph(), on page reset (when insert_bitmap returns reset=true),
   only invalidate cache entries for the reset page:

```v
if reset {
    // Invalidate only entries on the reset page
    reset_page := renderer.atlas.current_page
    for key, cached in renderer.cache {
        if cached.page == reset_page {
            renderer.cache.delete(key)
        }
    }
}
```

3. Update atlas.cleanup() to handle garbage from all pages.

4. Update draw_layout() and draw_layout_rotated():
   - When drawing glyph, select correct texture from pages[cached.page].image
   - For draw_layout_rotated, texture binding needs to potentially switch per-glyph
     (if different pages used) - group by page or accept per-glyph rebind cost

5. Update page age on use: When drawing a glyph, update that page's age:

```v
renderer.atlas.pages[cached.page].age = renderer.atlas.frame_counter
```

6. Increment frame_counter once per draw_layout call.

7. Update commit() to upload all dirty pages:

```v
for mut page in renderer.atlas.pages {
    if page.dirty {
        page.image.update_pixel_data(page.image.data)
        page.dirty = false
    }
}
```
  </action>
  <verify>
`v -check-syntax renderer.v glyph_atlas.v` passes.
`v fmt -w renderer.v glyph_atlas.v` formats.
`v test .` - existing tests pass.
  </verify>
  <done>
CachedGlyph.page tracks atlas page, renderer invalidates only affected page on reset,
draw functions use correct page texture.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update profile metrics for multi-page atlas</name>
  <files>context.v, api.v, glyph_atlas.v</files>
  <action>
Update ProfileMetrics (context.v) to aggregate multi-page stats:

The existing fields work, but calculation changes:
- atlas_used_pixels: sum of used_pixels across all pages
- atlas_total_pixels: sum of (width * height) across all pages

In api.v get_profile_metrics():

```v
// Calculate atlas utilization across all pages
mut used_pixels := i64(0)
mut total_pixels := i64(0)
for page in ts.renderer.atlas.pages {
    used_pixels += i64(page.cursor_y + page.row_height) * i64(page.width)
    total_pixels += i64(page.width) * i64(page.height)
}
```

Add page_count to ProfileMetrics (optional - useful for debugging):

```v
atlas_page_count int
```

Update print_summary() to show page count.

In glyph_atlas.v, track per-page stats:
- Each AtlasPage.used_pixels updated on insert
- atlas_resets increments when any page is reset (already handled)
  </action>
  <verify>
`v -check-syntax context.v api.v glyph_atlas.v` passes.
Build with `-d profile` succeeds.
Build without profile flag succeeds (zero overhead check).
  </verify>
  <done>
Profile metrics aggregate across all atlas pages, page_count visible in summary.
  </done>
</task>

</tasks>

<verification>
1. Compile: `v -check-syntax *.v` passes
2. Format: `v fmt -w *.v` completes
3. Tests: `v test .` - all existing tests pass
4. Profile build: `v -d profile examples/stress_demo.v` compiles
5. Release build: `v examples/stress_demo.v` compiles (no profile overhead)
</verification>

<success_criteria>
- LATENCY-01 addressed: Atlas grows to multiple pages before resetting
- CachedGlyph tracks page index
- Page reset only invalidates that page's cache entries
- Memory tracking sums across all pages
- No regression in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/09-latency-optimizations/09-01-SUMMARY.md`
</output>
