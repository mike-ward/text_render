---
phase: 08-instrumentation
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified: [context.v, renderer.v, glyph_atlas.v, api.v]
autonomous: true

must_haves:
  truths:
    - "Cache hit/miss rates trackable for glyph cache"
    - "Cache hit/miss rates trackable for layout cache"
    - "Atlas utilization shows used vs total pixels"
    - "Memory peak tracking shows growth"
    - "Developer can query all metrics via TextSystem.get_profile_metrics()"
  artifacts:
    - path: "context.v"
      provides: "Extended ProfileMetrics with cache/atlas/memory fields"
      contains: "glyph_cache_hits"
    - path: "renderer.v"
      provides: "Glyph cache hit/miss tracking"
      pattern: "glyph_cache_hits"
    - path: "glyph_atlas.v"
      provides: "Atlas utilization and memory tracking"
      pattern: "atlas_used_pixels"
    - path: "api.v"
      provides: "Layout cache tracking and unified get_profile_metrics API"
      pattern: "get_profile_metrics"
  key_links:
    - from: "api.v"
      to: "context.v"
      via: "TextSystem.get_profile_metrics aggregates Context.profile_metrics"
      pattern: "ctx\\.profile_metrics"
    - from: "api.v"
      to: "renderer.v"
      via: "TextSystem.get_profile_metrics aggregates Renderer stats"
      pattern: "renderer\\..*cache"
    - from: "api.v"
      to: "glyph_atlas.v"
      via: "TextSystem.get_profile_metrics reads atlas stats via Renderer"
      pattern: "atlas_inserts"
---

<objective>
Add cache statistics, atlas utilization, and memory tracking to ProfileMetrics. Expose unified
public API via TextSystem.get_profile_metrics().

Purpose: Enable developers to analyze cache efficiency, atlas memory usage, and identify
optimization opportunities from a single entry point.

Output: Complete ProfileMetrics with all INST fields, public get_profile_metrics() API on
TextSystem that aggregates metrics from Context, Renderer, and layout cache.

Note: INST-03 requires glyph, metrics, and layout cache tracking. Metrics cache doesn't exist
yet (introduced in Phase 9 LATENCY-02). This plan implements glyph + layout cache tracking.
Metrics cache tracking will be added in Phase 9 when the cache is implemented.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-instrumentation/08-RESEARCH.md
@.planning/phases/08-instrumentation/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ProfileMetrics with cache/atlas/memory fields</name>
  <files>context.v</files>
  <action>
Extend ProfileMetrics struct (from Plan 01) with additional fields:

```v
$if profile ? {
    pub struct ProfileMetrics {
    pub mut:
        // Frame timing (nanoseconds) - from Plan 01
        layout_time_ns     i64
        rasterize_time_ns  i64
        upload_time_ns     i64
        draw_time_ns       i64

        // Cache statistics (INST-03)
        glyph_cache_hits   int
        glyph_cache_misses int
        layout_cache_hits   int
        layout_cache_misses int
        // Note: metrics_cache_hits/misses added in Phase 9 when metrics cache implemented

        // Atlas statistics (INST-05)
        atlas_inserts       int
        atlas_grows         int
        atlas_resets        int
        atlas_used_pixels   i64
        atlas_total_pixels  i64

        // Memory tracking (INST-04)
        peak_atlas_bytes    i64
        current_atlas_bytes i64
    }

    // Derived metrics
    pub fn (m ProfileMetrics) glyph_cache_hit_rate() f32 {
        total := m.glyph_cache_hits + m.glyph_cache_misses
        if total == 0 { return 0.0 }
        return f32(m.glyph_cache_hits) / f32(total) * 100.0
    }

    pub fn (m ProfileMetrics) layout_cache_hit_rate() f32 {
        total := m.layout_cache_hits + m.layout_cache_misses
        if total == 0 { return 0.0 }
        return f32(m.layout_cache_hits) / f32(total) * 100.0
    }

    pub fn (m ProfileMetrics) atlas_utilization() f32 {
        if m.atlas_total_pixels == 0 { return 0.0 }
        return f32(m.atlas_used_pixels) / f32(m.atlas_total_pixels) * 100.0
    }

    pub fn (m ProfileMetrics) print_summary() {
        total_ns := m.layout_time_ns + m.rasterize_time_ns + m.upload_time_ns + m.draw_time_ns
        println('=== VGlyph Profile Metrics ===')
        println('Frame Time Breakdown:')
        println('  Layout:    ${m.layout_time_ns / 1000} us')
        println('  Rasterize: ${m.rasterize_time_ns / 1000} us')
        println('  Upload:    ${m.upload_time_ns / 1000} us')
        println('  Draw:      ${m.draw_time_ns / 1000} us')
        println('  Total:     ${total_ns / 1000} us')
        println('Glyph Cache: ${m.glyph_cache_hit_rate():.1}% (${m.glyph_cache_hits}/${m.glyph_cache_hits + m.glyph_cache_misses})')
        println('Layout Cache: ${m.layout_cache_hit_rate():.1}% (${m.layout_cache_hits}/${m.layout_cache_hits + m.layout_cache_misses})')
        println('Atlas: ${m.atlas_utilization():.1}% utilized (${m.atlas_used_pixels}/${m.atlas_total_pixels} px)')
        println('Memory: ${m.current_atlas_bytes / 1024} KB current, ${m.peak_atlas_bytes / 1024} KB peak')
    }
}
```
  </action>
  <verify>Run `v -d profile -check-syntax context.v` - no errors</verify>
  <done>ProfileMetrics has all INST-03/04/05 fields plus derived metric functions</done>
</task>

<task type="auto">
  <name>Task 2: Add cache and atlas tracking to renderer, glyph_atlas, and api</name>
  <files>renderer.v, glyph_atlas.v, api.v</files>
  <action>
**renderer.v - Track glyph cache hits/misses in get_or_load_glyph():**
```v
fn (mut renderer Renderer) get_or_load_glyph(item Item, glyph Glyph, bin int) !CachedGlyph {
    // ... key calculation ...

    if key in renderer.cache {
        $if profile ? {
            renderer.glyph_cache_hits++
        }
        return renderer.cache[key]
    }

    $if profile ? {
        renderer.glyph_cache_misses++
    }

    // ... load glyph ...
}
```

Add cache tracking fields to Renderer struct (extend existing $if profile ? block):
```v
$if profile ? {
    pub mut:
        rasterize_time_ns  i64
        upload_time_ns     i64
        draw_time_ns       i64
        glyph_cache_hits   int
        glyph_cache_misses int
}
```

**glyph_atlas.v - Track atlas operations in insert_bitmap() and grow():**

In insert_bitmap():
```v
pub fn (mut atlas GlyphAtlas) insert_bitmap(bmp Bitmap, left int, top int) !(CachedGlyph, bool) {
    $if profile ? {
        atlas.atlas_inserts++
    }

    // ... existing reset logic ...
    if atlas.height >= atlas.max_height {
        $if profile ? {
            atlas.atlas_resets++
        }
        // ... reset code ...
    }

    // ... rest of function ...
}
```

In grow():
```v
pub fn (mut atlas GlyphAtlas) grow(new_height int) ! {
    $if profile ? {
        atlas.atlas_grows++
    }
    // ... existing code ...

    // After allocation, update memory tracking
    $if profile ? {
        atlas.current_atlas_bytes = new_size
        if new_size > atlas.peak_atlas_bytes {
            atlas.peak_atlas_bytes = new_size
        }
    }
}
```

Add profile fields to GlyphAtlas struct:
```v
pub struct GlyphAtlas {
    // ... existing fields ...
    $if profile ? {
        pub mut:
            atlas_inserts       int
            atlas_grows         int
            atlas_resets        int
            current_atlas_bytes i64
            peak_atlas_bytes    i64
    }
}
```

Initialize peak_atlas_bytes in new_glyph_atlas():
```v
$if profile ? {
    atlas.current_atlas_bytes = size
    atlas.peak_atlas_bytes = size
}
```

**api.v - Track layout cache hits/misses in get_or_create_layout():**

Add profile fields to TextSystem struct:
```v
pub struct TextSystem {
mut:
    // ... existing fields ...
    $if profile ? {
        layout_cache_hits   int
        layout_cache_misses int
    }
}
```

In get_or_create_layout():
```v
fn (mut ts TextSystem) get_or_create_layout(text string, cfg TextConfig) !&CachedLayout {
    key := ts.get_cache_key(text, &cfg)

    mut item := ts.cache[key] or {
        $if profile ? {
            ts.layout_cache_misses++
        }
        layout := ts.ctx.layout_text(text, cfg)!
        new_item := &CachedLayout{
            layout:      layout
            last_access: 0
        }
        ts.cache[key] = new_item
        new_item
    }

    $if profile ? {
        // If we got here without the or block, it was a hit
        // V's or-block runs only on miss, so detect hit by checking if layout existed
        if key in ts.cache && item.last_access != 0 {
            ts.layout_cache_hits++
        }
    }

    item.last_access = time.ticks()
    return item
}
```

Note: The hit detection is tricky because V's or-block runs on miss. A cleaner approach:
```v
fn (mut ts TextSystem) get_or_create_layout(text string, cfg TextConfig) !&CachedLayout {
    key := ts.get_cache_key(text, &cfg)

    if key in ts.cache {
        $if profile ? {
            ts.layout_cache_hits++
        }
        mut item := ts.cache[key]
        item.last_access = time.ticks()
        return item
    }

    $if profile ? {
        ts.layout_cache_misses++
    }

    layout := ts.ctx.layout_text(text, cfg)!
    new_item := &CachedLayout{
        layout:      layout
        last_access: time.ticks()
    }
    ts.cache[key] = new_item
    return new_item
}
```
This refactor makes hit/miss tracking explicit. Use this cleaner version.
  </action>
  <verify>
Run `v -d profile -check-syntax renderer.v glyph_atlas.v api.v` - no errors.
Run `v -check-syntax renderer.v glyph_atlas.v api.v` (release) - no errors.
  </verify>
  <done>Glyph cache hits/misses tracked, layout cache hits/misses tracked, atlas inserts/grows/resets tracked, memory bytes tracked</done>
</task>

<task type="auto">
  <name>Task 3: Expose unified get_profile_metrics() API on TextSystem</name>
  <files>api.v</files>
  <action>
Add unified public API to TextSystem that aggregates ALL metrics from Context, Renderer, and
layout cache. This is the single entry point users interact with.

```v
$if profile ? {
    // get_profile_metrics returns aggregated profiling metrics from all subsystems.
    // Combines: Context timing, Renderer cache/timing, GlyphAtlas memory, TextSystem layout cache.
    // This is the primary API for accessing profiling data.
    pub fn (ts &TextSystem) get_profile_metrics() ProfileMetrics {
        // Calculate atlas utilization
        used_pixels := i64(ts.renderer.atlas.cursor_y + ts.renderer.atlas.row_height) * i64(ts.renderer.atlas.width)
        total_pixels := i64(ts.renderer.atlas.width) * i64(ts.renderer.atlas.height)

        return ProfileMetrics{
            // Timing from Context (layout) and Renderer (rasterize/upload/draw)
            layout_time_ns:    ts.ctx.profile_metrics.layout_time_ns
            rasterize_time_ns: ts.renderer.rasterize_time_ns
            upload_time_ns:    ts.renderer.upload_time_ns
            draw_time_ns:      ts.renderer.draw_time_ns

            // Glyph cache from Renderer
            glyph_cache_hits:   ts.renderer.glyph_cache_hits
            glyph_cache_misses: ts.renderer.glyph_cache_misses

            // Layout cache from TextSystem
            layout_cache_hits:   ts.layout_cache_hits
            layout_cache_misses: ts.layout_cache_misses

            // Atlas from GlyphAtlas (via Renderer)
            atlas_inserts:      ts.renderer.atlas.atlas_inserts
            atlas_grows:        ts.renderer.atlas.atlas_grows
            atlas_resets:       ts.renderer.atlas.atlas_resets
            atlas_used_pixels:  used_pixels
            atlas_total_pixels: total_pixels

            // Memory from GlyphAtlas
            current_atlas_bytes: ts.renderer.atlas.current_atlas_bytes
            peak_atlas_bytes:    ts.renderer.atlas.peak_atlas_bytes
        }
    }

    // reset_profile_metrics clears all profiling counters across all subsystems.
    pub fn (mut ts TextSystem) reset_profile_metrics() {
        // Reset Context timing
        ts.ctx.profile_metrics.layout_time_ns = 0

        // Reset Renderer timing and cache
        ts.renderer.rasterize_time_ns = 0
        ts.renderer.upload_time_ns = 0
        ts.renderer.draw_time_ns = 0
        ts.renderer.glyph_cache_hits = 0
        ts.renderer.glyph_cache_misses = 0

        // Reset TextSystem layout cache counters
        ts.layout_cache_hits = 0
        ts.layout_cache_misses = 0

        // Note: Don't reset atlas counters - they represent lifetime stats
    }
}
```

Run v fmt -w on all modified files.
  </action>
  <verify>
Run `v -d profile -check-syntax api.v` - no errors.
Verify get_profile_metrics() returns ProfileMetrics type with all fields populated.
Verify reset_profile_metrics() clears timing and cache counters.
  </verify>
  <done>
Unified API exposed via TextSystem.get_profile_metrics() and reset_profile_metrics().
Users get all metrics from single call: timing, glyph cache, layout cache, atlas, memory.
  </done>
</task>

</tasks>

<verification>
- [ ] ProfileMetrics has glyph_cache_hits/misses and layout_cache_hits/misses
- [ ] glyph_cache_hit_rate() and layout_cache_hit_rate() derived functions work
- [ ] print_summary() outputs both glyph and layout cache stats
- [ ] get_or_load_glyph (renderer.v) tracks glyph hits/misses
- [ ] get_or_create_layout (api.v) tracks layout hits/misses
- [ ] insert_bitmap tracks inserts/resets
- [ ] grow() tracks grows and memory bytes
- [ ] TextSystem.get_profile_metrics() aggregates ALL metrics (Context + Renderer + TextSystem)
- [ ] TextSystem.reset_profile_metrics() clears all counters
- [ ] Release build has zero profiling code (conditional compilation verified)
</verification>

<success_criteria>
- INST-01: Zero release overhead (conditional compilation)
- INST-02: Frame time breakdown (layout/rasterize/upload/draw)
- INST-03: Cache hit/miss rates tracked (glyph cache + layout cache)
  - Note: Metrics cache tracking deferred to Phase 9 (cache doesn't exist yet)
- INST-04: Memory tracking (peak_atlas_bytes, current_atlas_bytes)
- INST-05: Atlas utilization (used_pixels/total_pixels)

All implemented requirements satisfied. Metrics cache tracking added when Phase 9 implements it.
</success_criteria>

<output>
After completion, create `.planning/phases/08-instrumentation/08-02-SUMMARY.md`
</output>
