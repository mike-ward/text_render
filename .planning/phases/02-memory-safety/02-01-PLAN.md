---
phase: 02-memory-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - glyph_atlas.v
autonomous: true

must_haves:
  truths:
    - "grow() returns error instead of logging and silently failing"
    - "Allocations over 1GB are rejected with clear error"
    - "insert_bitmap propagates grow() failure to caller"
    - "All overflow/null checks use consistent helper function"
  artifacts:
    - path: "glyph_atlas.v"
      provides: "check_allocation_size helper, grow() !, insert_bitmap error propagation"
      contains: "fn check_allocation_size"
  key_links:
    - from: "grow()"
      to: "check_allocation_size"
      via: "size validation call"
      pattern: "check_allocation_size\\(atlas\\.width"
    - from: "insert_bitmap"
      to: "grow()"
      via: "error propagation"
      pattern: "atlas\\.grow.*\\?"
---

<objective>
Add memory safety checks with proper error propagation to glyph_atlas.v

Purpose: Replace silent failures (log + return) with error returns that callers can handle.
User decided: return errors, 1GB limit, shared helper, distinct error types.

Output: grow() returns !, insert_bitmap handles grow errors, check_allocation_size helper
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-memory-safety/02-CONTEXT.md
@.planning/phases/02-memory-safety/02-RESEARCH.md
@.planning/phases/01-error-propagation/01-01-SUMMARY.md
@glyph_atlas.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add check_allocation_size helper function</name>
  <files>glyph_atlas.v</files>
  <action>
Add helper function after gamma_table initialization (around line 21):

```v
const max_allocation_size = i64(1024 * 1024 * 1024) // 1GB

// check_allocation_size validates width * height * channels won't overflow or exceed limits.
// Returns validated size or error with specific cause.
fn check_allocation_size(w int, h int, channels int, location string) !i64 {
    size := i64(w) * i64(h) * i64(channels)
    if size <= 0 {
        return error('invalid allocation size in ${location}: ${w}x${h}x${channels}')
    }
    if size > max_i32 {
        return error('allocation overflow in ${location}: ${size} bytes exceeds max_i32')
    }
    if size > max_allocation_size {
        return error('allocation exceeds 1GB limit in ${location}: ${size} bytes')
    }
    return size
}
```

Note: location parameter enables distinct error messages per call site (user decision).
  </action>
  <verify>v -check-syntax glyph_atlas.v passes</verify>
  <done>check_allocation_size function exists, validates overflow, max_i32, and 1GB limit</done>
</task>

<task type="auto">
  <name>Task 2: Convert grow() to return error</name>
  <files>glyph_atlas.v</files>
  <action>
Change grow() signature and error handling:

1. Change signature from `pub fn (mut atlas GlyphAtlas) grow(new_height int)` to
   `pub fn (mut atlas GlyphAtlas) grow(new_height int) !`

2. Replace overflow check at lines 440-443:
   FROM:
   ```v
   if new_size > max_i32 || new_size <= 0 {
       log.error('${@FILE_LINE}: Atlas grow size overflow: ${atlas.width}x${new_height}')
       return
   }
   ```
   TO:
   ```v
   new_size := check_allocation_size(atlas.width, new_height, 4, 'grow')!
   ```

3. Replace null check at lines 446-449:
   FROM:
   ```v
   if new_data == unsafe { nil } {
       log.error('${@FILE_LINE}: Failed to allocate atlas memory: ${new_size} bytes')
       return
   }
   ```
   TO:
   ```v
   if new_data == unsafe { nil } {
       return error('allocation failed in grow: ${new_size} bytes')
   }
   ```

4. Remove old_size and new_size local calculations since check_allocation_size handles
   overflow. Keep old_size for vmemcpy:
   ```v
   old_size := i64(atlas.width) * i64(atlas.height) * 4
   new_size := check_allocation_size(atlas.width, new_height, 4, 'grow')!
   ```

Silent errors per user decision - no log.error calls, just return error.
  </action>
  <verify>v -check-syntax glyph_atlas.v passes</verify>
  <done>grow() returns !, uses check_allocation_size, no log.error calls</done>
</task>

<task type="auto">
  <name>Task 3: Update insert_bitmap to handle grow() error</name>
  <files>glyph_atlas.v</files>
  <action>
Change insert_bitmap to propagate grow() errors:

At line 399, change:
FROM: `atlas.grow(new_height)`
TO: `atlas.grow(new_height)!`

The `!` propagates the error to insert_bitmap's caller since insert_bitmap already
returns `!(CachedGlyph, bool)`.

This ensures that if grow() fails (overflow, null allocation, 1GB limit), the error
propagates up instead of silently failing and potentially causing incorrect atlas state.
  </action>
  <verify>v -check-syntax glyph_atlas.v passes; grep -n "atlas.grow.*!" glyph_atlas.v shows propagation</verify>
  <done>insert_bitmap propagates grow() errors via ! operator</done>
</task>

</tasks>

<verification>
1. `v -check-syntax glyph_atlas.v` - compiles without errors
2. `grep -n "check_allocation_size" glyph_atlas.v` - helper function exists
3. `grep -n "fn.*grow.*!" glyph_atlas.v` - grow returns error type
4. `grep -n "atlas.grow.*!" glyph_atlas.v` - insert_bitmap propagates error
5. `grep -n "log.error.*grow" glyph_atlas.v` - should return 0 results (silent errors)
</verification>

<success_criteria>
- grow() signature is `fn (mut atlas GlyphAtlas) grow(new_height int) !`
- check_allocation_size validates overflow, max_i32, and 1GB limit
- insert_bitmap uses `atlas.grow(new_height)!` to propagate errors
- No log.error calls in grow() - errors returned silently
- Code compiles with `v -check-syntax`
</success_criteria>

<output>
After completion, create `.planning/phases/02-memory-safety/02-01-SUMMARY.md`
</output>
