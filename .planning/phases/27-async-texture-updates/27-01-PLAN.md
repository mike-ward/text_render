---
phase: 27-async-texture-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - glyph_atlas.v
  - renderer.v
autonomous: true

must_haves:
  truths:
    - "Atlas pages use double-buffered staging (front/back []u8 per page)"
    - "CPU rasterizes into staging_back, GPU uploads from staging_front"
    - "commit() swaps buffers then uploads from front"
    - "Kill switch flag disables async, forces synchronous upload"
    - "Upload time visible in -d profile metrics"
    - "commit() -> draw ordering preserved (no frame corruption)"
  artifacts:
    - path: "glyph_atlas.v"
      provides: "AtlasPage with staging_front/staging_back buffers"
      contains: "staging_front"
    - path: "renderer.v"
      provides: "Async commit with swap + upload, sync fallback"
      contains: "swap_staging_buffers"
  key_links:
    - from: "glyph_atlas.v copy_bitmap_to_page"
      to: "staging_back buffer"
      via: "writes to staging_back instead of image.data"
      pattern: "staging_back"
    - from: "renderer.v commit()"
      to: "staging_front buffer"
      via: "swap then upload_pixel_data from front"
      pattern: "swap_staging_buffers"
    - from: "glyph_atlas.v new_atlas_page"
      to: "staging buffer allocation"
      via: "upfront allocation of both buffers"
      pattern: "staging_front.*staging_back"
---

<objective>
Add double-buffered pixel staging to atlas pages so CPU rasterization
overlaps with GPU texture upload.

Purpose: Eliminate CPU blocking during texture upload. Current
`commit()` calls `update_pixel_data(page.image.data)` synchronously.
With staging, CPU writes to `staging_back` during rasterization while
GPU reads from `staging_front` during upload.

Output: Modified `glyph_atlas.v` and `renderer.v` with staging buffer
infrastructure, async commit path, sync fallback kill switch, and
upload profiling.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-async-texture-updates/27-RESEARCH.md
@glyph_atlas.v
@renderer.v
@api.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add staging buffers to AtlasPage and reroute writes</name>
  <files>glyph_atlas.v</files>
  <action>
Modify `AtlasPage` struct to add staging buffers and kill switch:

```v
struct AtlasPage {
mut:
    image         gg.Image
    width         int
    height        int
    shelves       []Shelf
    dirty         bool
    age           u64
    used_pixels   i64
    staging_front []u8  // GPU upload source
    staging_back  []u8  // CPU rasterization target
}
```

Add `async_uploads` field to `GlyphAtlas`:

```v
pub struct GlyphAtlas {
pub mut:
    // ... existing fields ...
    async_uploads bool = true  // Kill switch: false = sync fallback
}
```

Modify `new_atlas_page`:
- Allocate `staging_front` and `staging_back` as `[]u8{len: int(size), init: 0}`
  alongside existing `image.data` allocation.
- Both buffers allocated upfront (per context decision).

Modify `copy_bitmap_to_page`:
- Write to `page.staging_back` instead of `page.image.data`.
- Change dst_ptr calculation:
  `dst_ptr := &u8(page.staging_back.data) + ((y + row) * page.width + x) * 4`

Modify `reset_page`:
- Zero `staging_back` with vmemset (it becomes the write target).
- Zero `staging_front` too (prevents stale data on next upload).
- Keep existing `page.image.data` zeroing for safety.

Modify `grow_page`:
- Reallocate both staging buffers to new size.
- Copy old `staging_back` content to new `staging_back`
  (preserves in-progress rasterization data).
- Old `staging_front` data can be discarded (will be overwritten
  at next swap).
- Allocate new staging buffers as `[]u8{len: int(new_size), init: 0}`,
  copy old staging_back content into new staging_back.

Add `swap_staging_buffers` method on `AtlasPage`:
```v
fn (mut page AtlasPage) swap_staging_buffers() {
    tmp := page.staging_front
    page.staging_front = page.staging_back
    page.staging_back = tmp
}
```

IMPORTANT: Do NOT modify `commit()` in this task (that's Task 2).
Do NOT change the `update_pixel_data` call yet.
  </action>
  <verify>
Run `v -check-syntax glyph_atlas.v` -- no errors.
Run `v fmt -w glyph_atlas.v` -- formats cleanly.
Run `v test .` from project root -- all 6 tests pass.
  </verify>
  <done>
AtlasPage has staging_front/staging_back allocated upfront.
copy_bitmap_to_page writes to staging_back.
GlyphAtlas has async_uploads kill switch (default true).
swap_staging_buffers method exists.
grow_page and reset_page handle staging buffers.
All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement async commit and sync fallback</name>
  <files>renderer.v</files>
  <action>
Rewrite `commit()` in renderer.v with two paths:

**Async path** (when `atlas.async_uploads == true`):
```v
pub fn (mut renderer Renderer) commit() {
    $if profile ? {
        start := time.sys_mono_now()
        defer {
            renderer.upload_time_ns += time.sys_mono_now() - start
        }
    }
    for mut page in renderer.atlas.pages {
        if page.dirty {
            page.swap_staging_buffers()
            page.image.update_pixel_data(page.staging_front.data)
            page.dirty = false
        }
    }
}
```

**Sync fallback** (when `atlas.async_uploads == false`):
```v
    if !renderer.atlas.async_uploads {
        for mut page in renderer.atlas.pages {
            if page.dirty {
                // Copy staging_back directly to image.data, upload
                unsafe {
                    vmemcpy(page.image.data, page.staging_back.data,
                        page.staging_back.len)
                }
                page.image.update_pixel_data(page.image.data)
                page.dirty = false
            }
        }
        return
    }
```

The sync path copies staging_back -> image.data -> GPU (no swap,
no overlap). This preserves original behavior for debugging.

Structure: check kill switch first, handle sync path with early return,
then async path below.

Profile timing wraps the entire method (both paths), measuring
CPU-side upload work. This is consistent with existing profiling
pattern (upload_time_ns already exists in Renderer).

Keep `update_pixel_data` signature -- it takes `voidptr` (raw pointer).
For async path, pass `page.staging_front.data`.
For sync path, pass `page.image.data` (after memcpy from staging_back).
  </action>
  <verify>
Run `v -check-syntax renderer.v` -- no errors.
Run `v fmt -w renderer.v` -- formats cleanly.
Run `v test .` from project root -- all 6 tests pass.
Build and run atlas_debug example:
`v run examples/atlas_debug.v` -- renders without corruption.
Build stress_demo: `v run examples/stress_demo.v` -- no visual
artifacts, text renders correctly.
  </verify>
  <done>
commit() has async path (swap + upload from front) and sync fallback.
Upload time measured in -d profile via existing upload_time_ns.
commit() -> draw ordering preserved (swap before upload).
No frame corruption in atlas_debug and stress_demo examples.
All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `v test .` -- all 6 existing tests pass (no regressions)
2. `v run examples/atlas_debug.v` -- atlas renders, no corruption
3. `v run examples/stress_demo.v` -- heavy text load, no artifacts
4. `v -d profile run examples/stress_demo.v` -- upload_time_ns
   appears in profile output
5. Grep for staging_front/staging_back in glyph_atlas.v confirms
   double-buffered staging per page
6. Grep for async_uploads in glyph_atlas.v confirms kill switch exists
</verification>

<success_criteria>
- Double-buffered staging (front/back) allocated per atlas page
- CPU writes to staging_back during rasterization
- commit() swaps buffers and uploads from staging_front
- Kill switch (async_uploads=false) forces synchronous path
- Upload time visible in -d profile metrics
- commit() -> draw ordering preserved
- All existing tests pass, examples render without corruption
</success_criteria>

<output>
After completion, create
`.planning/phases/27-async-texture-updates/27-01-SUMMARY.md`
</output>
